{
  "hash": "c944f7d7ada85ff0e78eee666a587d33",
  "result": {
    "markdown": "---\ntitle: \"Network Analysis in R\"\nsubtitle: \"\"\nauthor: \"David Schoch\"\nfooter: \"@schochastics\"\ninstitute: \"Workshop series for Ukraine\"\nshortcodes:\n  - misc.lua\nformat: \n  revealjs: \n    menu: true\n    progress: false\n    theme: \"schochastics.scss\"\n    slide-number: c/t\n    show-slide-number: all\n    code-line-numbers: false\nexecute: \n  cache: true\n  echo: true\n---\n\n::: {.cell hash='netAnaR_cache/revealjs/setup_0eb92d4fac77ee4e3abb6531d34860c5'}\n\n:::\n\n\n:::{.center-x}\n![](img/qr-code.png){width=\"400\"}  \n<https://schochastics.github.io/netAnaR2023>\n:::\n\n## My R universe\n\n<img src=\"img/hex.png\" width=\"400\">\n\n\n## My R universe\n\n<img src=\"img/hex_net.png\" width=\"605\">\n\n# A Short Introduction to Network Analysis\n\n\n## Why study networks?\nconventional research methods are often individual based\nand our models tend to model relations between variables\n\n:::{.fragment}\n**but nature and culture is structured as networks**\n:::\n\n:::{.fragment}\n- **society**\n- brain (neural networks)\n- organizations (who reports to whom)\n- economies (who sells to whom)\n- ecologies (who eats whom)\n:::\n\n:::{.fragment}\n**Position within a network is important for predicting outcomes**\n:::\n\n## From \"ordinary\" to network data\n\n<br>\n\n:::{.fragment}\n**atomic data**  \nindividuals or entities\n:::\n\n:::{.fragment}\n**dyadic data**  \ndependent pairs of individuals (e.g. couples)  \nbut treated as independent entities\n:::\n\n:::{.fragment}\n**networks**  \ninterdependent and overlapping dyads    \nusual (statistical) independence assumptions do not hold\n:::\n\n## 4 pillars of network analysis \n\n:::{.text15}\n\n 1. Social network analysis is motivated by a structural intuition based on ties linking social actors\n \n 2. It is grounded in systematic empirical data\n \n 3. It draws heavily on graphic imagery\n \n 4. It relies on the use of mathematical and/or computational models\n\n:::\n\n\n## Levels of Analysis\n\n<br>\n\n:::{.fragment}\n**dyad level**  \nFundamental unit of network data collection  \n(\"Does sharing offices lead to friendship?\") \n:::\n\n:::{.fragment}\n**node level**  \nAggregation of dyad level measurement  \n(\"Do actors with more friends have a stronger immune system?\")\n:::\n\n:::{.fragment}\n**network level**  \nAssessing overal structure of a network  \n(\"Do well connected networks diffuse ideas faster?\")\n:::\n\n:::{.fragment .text08}\nmore levels are possible (triads, groups, ...)\n:::\n\n## Types of relations I\n\n<br>\n\n:::{.fragment}\n**Relational states**  \n\n- Similarities: location, participation, attribute  \n- Relational roles: kinship, other roles  \n- Relational cognition: affective, perceptual\n:::\n\n:::{.fragment}\n**Relational events**  \n\n- Interactions: sold to, talked to, helped, ...\n- Flows: information, belief, money\n:::\n\n## Types of relations II\n\n<br>\n\n:::{.fragment}\n**undirected**  \nsymmetric relation\n:::\n\n:::{.fragment}\n**directed**  \nasymmetric relation, but can be bi-directional\n:::\n\n:::{.fragment}\n**valued**  \nstrength of relation, frequency of contact, etc.\n:::\n\n:::{.fragment}\n**signed**  \npositive and negative relations\n:::\n\n:::{.fragment}\n**or a mixture thereof**\n:::\n\n## Goals of analysis\n\n:::{.fragment}\n**Network variables as independent/explanatory**  \n\n> *Using network theory to explain the consequences of network properties*\n\nsocial capital, brokerage, adoption of innovation\n:::\n\n:::{.fragment}\n**Network variables as dependent/outcomes**  \n\n> *Using ______ theory to explain the antecendents of a network*\n\nhomophily, balance theory\n:::\n\n\n## A tiny bit of math\n\nnetwork data are represented as **graphs**  \n\"graph\" and \"network\" are technically different\n\n:::{.frame-box}\nA graph $G$ consists of a tuple $(V,E)$ where  \n$V=\\{1,2,\\ldots,n\\}$ are the nodes (or vertices)  \n$E\\subseteq \\{(i,j): i,j \\in V\\}$ are the edges (or ties)\n:::\n\n**Most methods rely on concepts from graph theory**\n\n# R Ecosystem for Networks\n\n##\n\n:::{.center-x}\n![](img/tidyverse-meme.jpg)\n:::\n\n\n## What is \"base R\" for networks?\n\n\n::: {.cell hash='netAnaR_cache/revealjs/cranet_8f7d573a03c45bf175cb5bafb70da90c'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/cranet-1.png){width=960}\n:::\n:::\n\n\n\n## Which package to choose?\n\n<br>\n\nuse `igraph` if\n\n- you need speed (large networks)\n- you need to use other SNA packages\n\n:::{.fragment}\nuse `sna` if\n\n- you need to do modeling (e.g. ERGMs and RSIENA)\n:::\n\n:::{.fragment}\n**does not make a difference in most cases, never load them both!**\n:::\n\n## Creating simple networks\n\n\n::: {.cell hash='netAnaR_cache/revealjs/make_graph_f8f9a44997b3747b3bd6cf560348d204'}\n\n```{.r .cell-code}\ng1 <- make_graph(c(1,2, 1,3, 2,3, 2,4, 3,5, 4,5), n = 5, dir = FALSE)\ng2 <- graph_from_literal(Joey-Chandler:Monica-Ross, Joey-Ross-Rachel)\n```\n:::\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/make_graph_lot_449fd03df4af75c522097290028c9ba6'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/make_graph_lot-1.png){width=384}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell hash='netAnaR_cache/revealjs/make_literal_lot_9158f3a66d4a2695485491b1ec2c8e75'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/make_literal_lot-1.png){width=384}\n:::\n:::\n\n\n:::\n\n::::\n\n## Special graphs\n\n\n::: {.cell hash='netAnaR_cache/revealjs/make_examples_344821a9b44dd498d45ee502a3b8a412'}\n\n```{.r .cell-code}\ng3 <- make_full_graph(n = 10)\ng4 <- make_ring(n = 10)\ng5 <- make_empty_graph(n = 10)\n```\n:::\n\n\n:::: {.columns}\n::: {.column width=\"33%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/full_graph_plot_02cdd2e15f730ad57920e16ce9ee605e'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/full_graph_plot-1.png){width=288}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"33%\"}\n\n\n::: {.cell hash='netAnaR_cache/revealjs/ring_plot_41e89a07f5844612451fbca7a8f68a67'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/ring_plot-1.png){width=288}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"33%\"}\n\n\n::: {.cell hash='netAnaR_cache/revealjs/empty_plot_f137e8a83697949ca8917cf52059ff4b'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/empty_plot-1.png){width=288}\n:::\n:::\n\n\n:::\n\n\n::::\n\n\n::: {.cell hash='netAnaR_cache/revealjs/igraph_make_de67f3d37430da1684b59fcddfc05c13'}\n\n```{.r .cell-code}\nls(\"package:igraph\",pattern = \"make_*\")\n```\n:::\n\n\n## Random graphs\n\n\n::: {.cell hash='netAnaR_cache/revealjs/make_randoms_eaa19895ff444563656bd116134277b0'}\n\n```{.r .cell-code}\ng6 <- sample_gnp(n = 100,p = 0.1)\ng7 <- sample_pa(n = 100, power = 1.5, m = 1, directed = FALSE)\n```\n:::\n\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/er_plot_60c6ada90bd052a14c70b432b5336b70'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/er_plot-1.png){width=384}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell hash='netAnaR_cache/revealjs/pa_plot_d6a4f55ff9e9308db9e8c0591089e076'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/pa_plot-1.png){width=384}\n:::\n:::\n\n\n:::\n::::\n\n\n::: {.cell hash='netAnaR_cache/revealjs/igraph_sample_c2b574e33b21f37f7a81a06102714e73'}\n\n```{.r .cell-code}\nls(\"package:igraph\",pattern = \"sample_*\")\n```\n:::\n\n\n## igraph objects \n\n\n\n::: {.cell hash='netAnaR_cache/revealjs/igraph_obj_d3908b8a3b7a08ec319802fd84082124'}\n\n```{.r .cell-code}\ng2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 072acab UN-- 5 6 -- \n+ attr: name (v/c)\n+ edges from 072acab (vertex names):\n[1] Joey    --Chandler Joey    --Monica   Joey    --Ross     Chandler--Ross    \n[5] Monica  --Ross     Ross    --Rachel  \n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/str_igraph_19473ef8c1ae860d081e9e69912f13c9'}\n\n```{.r .cell-code}\nlibrary(netUtils)\nstr(g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-----------------------------------------------------------\nUNNAMED NETWORK (undirected, unweighted, one-mode network)\n-----------------------------------------------------------\nNodes: 5, Edges: 6, Density: 0.6, Components: 1, Isolates: 0\n-Vertex Attributes:\n name(c): Joey, Chandler, Monica, Ross, Rachel ...\n---\n-Edges: \n Joey--Chandler Joey--Monica Joey--Ross Chandler--Ross Monica--Ross\nRoss--Rachel\n```\n:::\n:::\n\n\n## Attributes\n\n:::{.fragment}\n**node attributes**\n\n::: {.cell hash='netAnaR_cache/revealjs/vadd_attr_02f11d0e81333df5aae2ed0228531af2'}\n\n```{.r .cell-code}\nV(g2)$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Joey\"     \"Chandler\" \"Monica\"   \"Ross\"     \"Rachel\"  \n```\n:::\n\n```{.r .cell-code}\nV(g2)$gender <- c(\"M\",\"M\",\"F\",\"M\",\"F\") \n# g2 <- set_vertex_attr(\"gender\", c(\"M\",\"M\",\"F\",\"M\",\"F\"))\n```\n:::\n\n:::\n\n:::{.fragment}\n**edge attributes**\n\n\n::: {.cell hash='netAnaR_cache/revealjs/eadd_attr_3073fd717a0b6c8121cf5c168f3231de'}\n\n```{.r .cell-code}\nE(g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n+ 6/6 edges from 072acab (vertex names):\n[1] Joey    --Chandler Joey    --Monica   Joey    --Ross     Chandler--Ross    \n[5] Monica  --Ross     Ross    --Rachel  \n```\n:::\n\n```{.r .cell-code}\nE(g2)$weight <- sample(1:5,size = 6, replace = TRUE)\n# g2 <- set_edge_attr(\"weight\", sample(1:5,size = 6, replace = TRUE))\n```\n:::\n\n:::\n\n## Attributes\n\n\n::: {.cell hash='netAnaR_cache/revealjs/igraph_obj1_2946801bbc9f859c01ce46e798409d91'}\n\n```{.r .cell-code}\ng2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 072acab UNW- 5 6 -- \n+ attr: name (v/c), gender (v/c), weight (e/n)\n+ edges from 072acab (vertex names):\n[1] Joey    --Chandler Joey    --Monica   Joey    --Ross     Chandler--Ross    \n[5] Monica  --Ross     Ross    --Rachel  \n```\n:::\n:::\n\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/str_igraph1_3b6641e3d74f40c2cf6810c34775476a'}\n\n```{.r .cell-code}\nstr(g2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n---------------------------------------------------------\nUNNAMED NETWORK (undirected, weighted, one-mode network)\n---------------------------------------------------------\nNodes: 5, Edges: 6, Density: 0.6, Components: 1, Isolates: 0\n-Vertex Attributes:\n name(c): Joey, Chandler, Monica, Ross, Rachel ...\n gender(c): M, M, F, M, F ...\n---\n-Edge Attributes:\n weight(n): 3, 1, 4, 2, 5, 5 ...\n---\n-Edges: \n Joey--Chandler Joey--Monica Joey--Ross Chandler--Ross Monica--Ross\nRoss--Rachel\n```\n:::\n:::\n\n\n## Network representations: adjacency matrix\n\n\n::: {.cell hash='netAnaR_cache/revealjs/adj_mat_5f78ab3b5a4462de1b809fa11cf390f7'}\n\n```{.r .cell-code}\nA <- matrix(\n  c(0, 1, 1,\n    1, 0, 1,\n    1, 1, 0),\n  nrow = 3, ncol = 3, byrow = TRUE)\nrownames(A) <- c(\"Bob\",\"Ann\",\"Steve\")\ncolnames(A) <- c(\"Bob\",\"Ann\",\"Steve\")\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      Bob Ann Steve\nBob     0   1     1\nAnn     1   0     1\nSteve   1   1     0\n```\n:::\n:::\n\n\n- $A_{ij}=1$ if there is an edge between $i$ and $j$\n- $A$ is symmetric for undirected networks \n- If $A_{ij}>1$ then the values are interpreted as weights \n\n## Network representation: edgelist\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/edge_lst_c2e3678623df7f9f657f6eea30f9c95d'}\n\n```{.r .cell-code}\nel <- matrix(\n  c(\"Bob\",\"Ann\",\n    \"Bob\",\"Steve\",\n    \"Ann\",\"Steve\"),\n  nrow = 3,ncol = 2, byrow = TRUE)\nel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1]  [,2]   \n[1,] \"Bob\" \"Ann\"  \n[2,] \"Bob\" \"Steve\"\n[3,] \"Ann\" \"Steve\"\n```\n:::\n:::\n\n\nmore efficient for sparse data (null edges aren't stored)\n\n## Networks from matrices and lists\n\n**adjacency matrix**\n\n::: {.cell hash='netAnaR_cache/revealjs/from_adj_b1b84ed9b8ec4588b2ab475e94154244'}\n\n```{.r .cell-code}\ngraph_from_adjacency_matrix(\n  A,\n  mode = \"undirected\",\n  weighted = NULL,\n  diag = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 1c98609 UN-- 3 3 -- \n+ attr: name (v/c)\n+ edges from 1c98609 (vertex names):\n[1] Bob--Ann   Bob--Steve Ann--Steve\n```\n:::\n:::\n\n\n**edgelist**\n\n::: {.cell hash='netAnaR_cache/revealjs/from_edgelist_25a20b6b1076c6d394255f54e6f8ece8'}\n\n```{.r .cell-code}\ngraph_from_edgelist(el, directed = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGRAPH 43282b1 UN-- 3 3 -- \n+ attr: name (v/c)\n+ edges from 43282b1 (vertex names):\n[1] Bob--Ann   Bob--Steve Ann--Steve\n```\n:::\n:::\n\n::: {.cell hash='netAnaR_cache/revealjs/graph_from_15a0089df65cda28cabc898ffe745b26'}\n\n```{.r .cell-code}\nls(\"package:igraph\",pattern = \"graph_from_*\")\n```\n:::\n\n\n## Reading network data\n\n<br>\n\n:::{.fragment}\n**Data is already in R (e.g. `networkdata`)**  \nNo extra work\n:::\n\n:::{.fragment}\n**Data was processed in another SNA tool**  \n\n::: {.cell hash='netAnaR_cache/revealjs/read_graph_523cec45ccf51abab8876a06ea197a10'}\n\n```{.r .cell-code}\nread_graph(file, format = c(\"edgelist\", \"pajek\", \"ncol\", \"lgl\",\n  \"graphml\", \"dimacs\", \"graphdb\", \"gml\", \"dl\"), ...)\n```\n:::\n\nSome extra work (with some issues) \n:::\n\n:::{.fragment}\n**Data is in a csv/spreadsheet/..**  \n`read.table()`, `read.csv()`, {{< CRAN readxl >}}, {{< CRAN readr >}},...\n:::\n\n## Preparing network data with attributes {.smaller}\n\n**Organize network data in two separate files**\n\n::::{.columns}\n:::{.column width=\"50%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/el_df_7c3bc8bd5aaa3ad1efd98f0defc15880'}\n::: {.cell-output-display}\n|from            |to             |\n|:---------------|:--------------|\n|Arizona Robbins |Leah Murphy    |\n|Alex Karev      |Leah Murphy    |\n|Arizona Robbins |Lauren Boswell |\n|Arizona Robbins |Callie Torres  |\n|Erica Hahn      |Callie Torres  |\n|Alex Karev      |Callie Torres  |\n:::\n:::\n\n:::\n:::{.column width=\"50%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/node_df_6ec3e8e85b33e8e7a0bc19a34ba93bed'}\n::: {.cell-output-display}\n|name               |sex | birthyear|\n|:------------------|:---|---------:|\n|Addison Montgomery |F   |      1967|\n|Adele Webber       |F   |      1949|\n|Teddy Altman       |F   |      1969|\n|Amelia Shepherd    |F   |      1981|\n|Arizona Robbins    |F   |      1976|\n|Rebecca Pope       |F   |      1975|\n:::\n:::\n\n:::\n:::\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/df1_1adaba0fbbc957b42c1c29177106984f'}\n\n```{.r .cell-code}\ngraph_from_data_frame(el, directed = c(TRUE, FALSE), vertices)\n```\n:::\n\n\n# Descriptive Statistics and some graph theory\n\n## Toy example\n\n::: {.cell hash='netAnaR_cache/revealjs/load_greys_ee69192740195ad99d438bfaa522015a'}\n\n```{.r .cell-code}\ndata(\"greys\")\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/plot_greys_cf100004335c34057dec12ce2b090dd1'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/plot_greys-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n## Density\n\n<br>\n\nThe **density** of a network is defined as the fraction of the potential edges in a network that are actually present.\n\n::: {.cell hash='netAnaR_cache/revealjs/density_11e03fa834d2d1244d9ec8bd4cbaa270'}\n\n```{.r .cell-code}\nc(graph.density(make_empty_graph(10)), \n  graph.density(greys), \n  graph.density(make_full_graph(10)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0000000 0.0398323 1.0000000\n```\n:::\n:::\n\n\n## Shortest Paths\n\nA **shortest path** is a path that connects two nodes in a network with a minimal number of edges. The length of a shortest path is called the distance between two nodes.\n\n\n::: {.cell hash='netAnaR_cache/revealjs/shortest_path_930b1b1db299c24cf027c0b49e44b968'}\n\n```{.r .cell-code}\nshortest_paths(greys,from = \"Alex Karev\",to = \"Owen Hunt\",output = \"vpath\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$vpath\n$vpath[[1]]\n+ 5/54 vertices, named, from f7716f1:\n[1] Alex Karev         Addison Montgomery Mark Sloan         Teddy Altman      \n[5] Owen Hunt         \n\n\n$epath\nNULL\n\n$predecessors\nNULL\n\n$inbound_edges\nNULL\n```\n:::\n:::\n\n\n## Shortest Paths\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/greys_shortest_path_92625c5c7a8445bebc5de4ca9a52763a'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/greys_shortest_path-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n## Distances\n\n\n::: {.cell hash='netAnaR_cache/revealjs/distances_67ec88a8b4b1c1fbd1a57e092412f824'}\n\n```{.r .cell-code}\ndistances(greys)[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   Addison Montgomery Adele Webber Teddy Altman Amelia Shepherd\nAddison Montgomery                  0          Inf            2               2\nAdele Webber                      Inf            0          Inf             Inf\nTeddy Altman                        2          Inf            0               2\nAmelia Shepherd                     2          Inf            2               0\nArizona Robbins                     3          Inf            3               3\n                   Arizona Robbins\nAddison Montgomery               3\nAdele Webber                   Inf\nTeddy Altman                     3\nAmelia Shepherd                  3\nArizona Robbins                  0\n```\n:::\n:::\n\n\nThe Grey's Anatomy network is **disconnected** ($4$ **connected components**)\n\n## Diameter\n\nThe length of the longest shortest path is called the **diameter** of the network.\n\n\n::: {.cell hash='netAnaR_cache/revealjs/diameter_fa80a9353636954048dc8f9c3077cb1c'}\n\n```{.r .cell-code}\ndiameter(greys)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/greys_diameter_e7f3be4aa8ad104aaf10830563a75174'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/greys_diameter-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n## Transitivity\n\n**Transitivity** is a measure of the degree to which nodes in a graph tend to cluster together. This is also called the **clustering coefficient**. \n\n**local**  \ngives an indication of the embeddedness of single nodes\n\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/ccoef_example_47fb73942d68cee3977b77e04da25c7f'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/ccoef_example-1.png){fig-align='center' width=1440}\n:::\n:::\n\n\n:::: {.columns}\n\n::: {.column width=\"65%\"}\n**global**  \nindication of the clustering in the network\n:::\n\n::: {.column width=\"35%\"}\n$$\n\\frac{3 \\times \\text{number of triangles} }{\\text{total number of triplets}}\n$$\n\n:::\n\n::::\n\n## Transitivity\n\n::: {.cell hash='netAnaR_cache/revealjs/transitivity_bee9636221312e1003a902072bcd25c3'}\n\n```{.r .cell-code}\ndata(\"coleman\")\ng <- as.undirected(coleman[[1]])\ntransitivity(g, type = \"global\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.440083\n```\n:::\n:::\n\n::: {.cell hash='netAnaR_cache/revealjs/transitivity2_7ee3407df9927ecee2d2a11068b9449a'}\n\n```{.r .cell-code}\ntransitivity(g, type = \"local\", isolates = \"zero\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0.400000 1.000000 0.000000 0.500000 0.666667 1.000000 0.000000 0.000000\n [9] 0.533333 0.000000 0.400000 1.000000 0.333333 0.333333 0.000000 0.333333\n[17] 0.000000 0.400000 0.333333 0.428571 0.303030 0.377778 0.305556 0.000000\n[25] 0.000000 0.266667 0.333333 0.000000 0.000000 1.000000 0.166667 0.400000\n[33] 0.700000 1.000000 0.333333 0.700000 0.666667 0.285714 0.200000 0.200000\n[41] 0.466667 0.600000 0.266667 0.000000 0.700000 0.500000 0.600000 0.466667\n[49] 0.666667 0.571429 0.333333 0.571429 0.666667 0.266667 0.357143 0.666667\n[57] 0.600000 1.000000 0.500000 0.600000 0.666667 0.500000 0.800000 0.700000\n[65] 0.600000 0.714286 0.866667 0.244444 0.714286 0.377778 0.488889 0.000000\n[73] 0.000000\n```\n:::\n:::\n\n\nIn empirical networks, we often observe a tendency towards high transitivity (\"the friend of a friend is a friend\")  \n\nWhat do you think is the (local/global) transitivity of `greys`?\n\n## Transitivity\n<br>\n\nThe value itself is not always enough to judge the level of transitivity of a network. We should also check if it deviates significantly from what would be expected by randomness\n\n\n::: {.cell hash='netAnaR_cache/revealjs/transitivity3_dd919ade6c92ee9216f1d953a4f226bf'}\n\n```{.r .cell-code}\ndeg <- degree(g)\n# keep density fixed\nmean(replicate(500,transitivity(rewire(g,each_edge(1)),type = \"global\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0679633\n```\n:::\n\n```{.r .cell-code}\n# keep degree sequence fixed\nmean(replicate(500,transitivity(sample_degseq(deg),type = \"global\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0742958\n```\n:::\n:::\n\n## Degree distribution\n\n<br>\n\nThe **degree** of a node in a network is the number of connections it has to other nodes.\n\nThe **degree distribution** is the probability distribution of the degrees over the whole network.\n\nEmpirical degree distributions are generally right skewed.  \n(Many nodes have a few conncetions and few have many)\n\"preferential attachment\", \"matthew effect\", \"the rich get richer\"  \n\n## Degree distribution\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/deg_dist_graphs_106abe5a77a88911b630c551cbedf85c'}\n\n```{.r .cell-code}\ner <- sample_gnp(n = 5000, p = 0.01)\npa <- sample_pa(n = 5000, power = 1.5, m = 2, directed = FALSE)\n```\n:::\n\n\n<br>\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell hash='netAnaR_cache/revealjs/dd_er_af5cfa945a20a71d90e142e6d0b6061b'}\n\n```{.r .cell-code}\nplot(degree_distribution(er))\n```\n\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/dd_er-1.png){width=960}\n:::\n:::\n\n\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell hash='netAnaR_cache/revealjs/dd_pa_30aa62f3a3e0da5ea0415f48194365ff'}\n\n```{.r .cell-code}\nplot(degree_distribution(pa),log = \"xy\")\n```\n\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/dd_pa-1.png){width=960}\n:::\n:::\n\n\n:::\n\n::::\n\n## Centrality\n\nA **measure of centrality** is an index that assigns a numeric values to\nthe nodes of the network. The higher the value, the more central the node. \n\n\"Being central\" is a very ambiguous term hence there exists a large variety of indices that assess centrality with very different structural properties.\n\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/star_net_04a11b7f523e8e90977da7704d1f00a5'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/star_net-1.png){fig-align='center' width=384}\n:::\n:::\n\n\n\n##\n\n\n::: {.cell hash='netAnaR_cache/revealjs/periodic_d3572388ada1a981d40539de74d043fe'}\n::: {.cell-output-display}\n![](img/periodic_table.png){width=835}\n:::\n:::\n\n\n## Standard indices {.text09}\n\n**Degree**  \nNumber of direct neighbors (\"popularity\")  \n\n**Closeness**  \nReciprocal of the sum of the length of the shortest paths\n\n**Betweenness**  \nNumber of shortest paths that pass through a node (\"brokerage\")\n\n**Eigenvector**  \nBeing central means being connected to other central nodes\n\n**PageRank**  \nSimilar to eigenvector, just for directed networks \n\n## Toy example I\n\n\n::: {.cell hash='netAnaR_cache/revealjs/load_dbces_d80963fd3986b60d45ac6a5d398ac953'}\n\n```{.r .cell-code}\ndata(\"dbces11\")\n```\n:::\n\n::: {.cell hash='netAnaR_cache/revealjs/dbces11_basic_plot_42e125c1c40f1adde57b32642979ee99'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/dbces11_basic_plot-1.png){width=960}\n:::\n:::\n\n\n## Toy example I\n\n\n::: {.cell hash='netAnaR_cache/revealjs/load_dbces1_aa3408788ded8761051cfb955e2bd778'}\n\n```{.r .cell-code}\ndata(\"dbces11\")\n```\n:::\n\n::: {.cell hash='netAnaR_cache/revealjs/dbces11_plot_bd954251a7d8640f30580d78929d6837'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/dbces11_plot-1.png){width=960}\n:::\n:::\n\n\n\n## Implemented indices {.smaller}\n\n`igraph` contains the following 10 indices:\n\n- [degree (`degree()`)]{.highlight}\n- [weighted degree (`strength()`)]{.highlight}\n- [betweenness (`betweenness()`)]{.highlight}\n- [closeness (`closeness()`)]{.highlight}\n- [eigenvector (`eigen_centrality()`)]{.highlight}\n- alpha centrality (`alpha_centrality()`)\n- power centrality (`power_centrality()`)\n- [PageRank (`page_rank()`)]{.highlight}\n- eccentricity (`eccentricity()`)\n- hubs and authorities (`authority_score()` and `hub_score()`)\n- subgraph centrality (`subgraph_centrality()`)\n\n## Indices in the sna package\n\nThe `sna` package implements roughly the same indices as but adds:\n\n- flow betweenness (`flowbet()`)\n- load centrality (`loadcent()`)\n- Gil-Schmidt Power Index (`gilschmidt()`)\n- information centrality (`infocent()`)\n- stress centrality (`stresscent()`)\n\n## Dedicated packages\n\n\n{{< CRAN centiserve >}}, {{< CRAN CINNA >}}  \n\n\n::: {.cell hash='netAnaR_cache/revealjs/centiserve_ea957664bc4ef2149f6731afe317bd4e'}\n\n```{.r .cell-code}\nlibrary(centiserve)\nas.character(lsf.str(\"package:centiserve\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"averagedis\"            \"barycenter\"            \"bottleneck\"           \n [4] \"centroid\"              \"closeness.currentflow\" \"closeness.freeman\"    \n [7] \"closeness.latora\"      \"closeness.residual\"    \"closeness.vitality\"   \n[10] \"clusterrank\"           \"communibet\"            \"communitycent\"        \n[13] \"crossclique\"           \"decay\"                 \"diffusion.degree\"     \n[16] \"dmnc\"                  \"entropy\"               \"epc\"                  \n[19] \"geokpath\"              \"hubbell\"               \"katzcent\"             \n[22] \"laplacian\"             \"leaderrank\"            \"leverage\"             \n[25] \"lincent\"               \"lobby\"                 \"markovcent\"           \n[28] \"mnc\"                   \"pairwisedis\"           \"radiality\"            \n[31] \"salsa\"                 \"semilocal\"             \"topocoefficient\"      \n```\n:::\n:::\n\n\n[centiserver](http://www.centiserver.org/) lists more than 400 indices\n\nCINNA:  \nComputing and comparing top informative centrality measures \n\n## Alternatives?\n\n{{< CRAN netrankr >}}:  \nTools which allow an indexfree assessment of centrality, including:  \n\n- partial centrality\n- expected centrality\n- probabilistic centrality\n\n:::{.callout-tip}\n## Help\n\nTutorials and material for using netrankr can be found at [netrankr.schochastics.net](http://netrankr.schochastics.net/)\n\n:::\n\n# \n\n## Cohesive groups\n\nCohesive subgroups are subsets of actors among whom there are relatively strong, direct, intense, frequent, or positive ties. \n\nMethods that formalize the intuitive and theoretical notion of social group using social network properties\n\n:::{.center-x}\n![](img/cohesive.png){width=\"950\"}\n:::\n\n## Cliques\n\nA *clique* in a network is a set of nodes that form a complete subnetwork within a network (called a complete **subgraph**). \n\nA **maximal clique** is a clique that cannot be extended to a bigger clique by addding more nodes to it. \n\n\n::: {.cell hash='netAnaR_cache/revealjs/load_clique_graph_cf0107ecc613723588792215115629d4'}\n\n```{.r .cell-code}\ndata(\"clique_graph\")\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/clique_graph_88b0804efc217fa0469b5e298ad447bb'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/clique_graph-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Cliques\n\nMaximal cliques can be calculated with `max_cliques()` \n\n::: {.cell hash='netAnaR_cache/revealjs/calc_max_cliques_3c5424cbb9082b0645fd0c7b37ace739'}\n\n```{.r .cell-code}\n# only return cliques with three or more nodes\ncl <- max_cliques(clique_graph,min = 3)\ncl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n+ 3/30 vertices, from 0193e05:\n[1]  9 17 18\n\n[[2]]\n+ 3/30 vertices, from 0193e05:\n[1] 7 4 5\n\n[[3]]\n+ 3/30 vertices, from 0193e05:\n[1] 7 4 8\n\n[[4]]\n+ 3/30 vertices, from 0193e05:\n[1] 10  2 11\n\n[[5]]\n+ 3/30 vertices, from 0193e05:\n[1] 16 12 15\n\n[[6]]\n+ 3/30 vertices, from 0193e05:\n[1] 6 1 5\n\n[[7]]\n+ 4/30 vertices, from 0193e05:\n[1] 12 13 15 14\n\n[[8]]\n+ 3/30 vertices, from 0193e05:\n[1] 12  2  1\n\n[[9]]\n+ 5/30 vertices, from 0193e05:\n[1] 1 2 5 4 3\n```\n:::\n:::\n\n\n## Cliques\n\n\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/clique_graph_2_cda8d08e62449be147f16b5c689b5723'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/clique_graph_2-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## k-core decomposition\n\nA **k-core** is a subgraph in which every node has at least k neighbors within the subgraph. A k-core is thus a relaxed version of a clique.  \n\n\n::: {.cell hash='netAnaR_cache/revealjs/kcore_7efecebbd2ea2035958ab033b5023b24'}\n\n```{.r .cell-code}\nkcore <- coreness(clique_graph)\nkcore\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 4 4 4 4 4 3 2 2 2 2 2 3 3 3 3 3 2 2 1 1 1 1 1 1 1 1 1 1 1 1\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/kcore_plot_fea66a0f55864e8e6cb1ab3d8e2b71ae'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/kcore_plot-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Clustering/Community detection\n\n**Minimum-cut method**  \ncut graph into partitions which minimizes some metric\n\n**Hierarchical clustering**  \nAgglomerative/Divisive methods to build a hierarchy of clusters  \nbased on node similarity\n\n**Modularity Maximization**  \nModularity is defined as the fraction of edges that fall within given groups minus the expected fraction if edges were random\n\n**Statistical inference**  \n[stochastic blockmodeling](https://graph-tool.skewed.de/) based on generative models\n\n## Min Cut clustering\n\n\n::: {.cell hash='netAnaR_cache/revealjs/mincut_d0d2c8e45494f1df06cf49f3cb61f786'}\n\n```{.r .cell-code}\ng <- sample_islands(2,10,0.9,5)\ng <- simplify(g)\n```\n:::\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/mincut_plot_f4a779b7c551bfffa997cc8df8a11c96'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/mincut_plot-1.png){fig-align='center' width=384}\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/mincut_calc_54b9f9a20b4cd35383fba13c2979f661'}\n\n```{.r .cell-code}\nmin_cut(g,value.only = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$value\n[1] 5\n\n$cut\n+ 5/84 edges from b4fdf2e (vertex names):\n[1] 1--16 3--15 4--12 6--14 6--18\n\n$partition1\n+ 10/20 vertices, named, from b4fdf2e:\n [1] 19 14 11 12 17 16 13 18 15 20\n\n$partition2\n+ 10/20 vertices, named, from b4fdf2e:\n [1] 1  2  3  4  5  6  7  8  9  10\n```\n:::\n:::\n\n:::\n::::\n\nReally only works in very obvious cases.\n\n## Hierarchical clustering\n\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/hierarch_clust_02453350560c9ef6b4efe3f13adeb252'}\n\n```{.r .cell-code}\nD <- distances(g)\nhclust_avg <- hclust(as.dist(D), method = \"average\")\ncut_avg <- cutree(hclust_avg, k = 2)\n\nplot(hclust_avg)\nrect.hclust(hclust_avg , k = 2, border = 2:6)\nabline(h = 2, col = 'red')\n```\n\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/hierarch_clust-1.png){fig-align='center' width=768}\n:::\n:::\n\n\n\n## Clustering with igraph\n\n<br>\n\n- There is no agreed upon best method\n- Modularity maximization is still widely considered \"state-of-the-art\"\n- Generative models are, however, a strong contender  \n  (not implemented in R yet)\n\n\n::: {.cell hash='netAnaR_cache/revealjs/cluster_alg_4d40e619bb03a2ecb5240415b1f8e1b5'}\n\n```{.r .cell-code}\nls(\"package:igraph\",pattern = \"cluster_\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"cluster_edge_betweenness\"  \"cluster_fast_greedy\"      \n [3] \"cluster_fluid_communities\" \"cluster_infomap\"          \n [5] \"cluster_label_prop\"        \"cluster_leading_eigen\"    \n [7] \"cluster_leiden\"            \"cluster_louvain\"          \n [9] \"cluster_optimal\"           \"cluster_spinglass\"        \n[11] \"cluster_walktrap\"         \n```\n:::\n:::\n\n\n## Clustering workflow\n\n\n::: {.cell hash='netAnaR_cache/revealjs/karate_ddc1ef1a110bbde27f6be576fbf571c0'}\n\n```{.r .cell-code}\ndata(\"karate\")\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/karate_plot_400989673fb18c2b61789325b1a693b5'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/karate_plot-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Clustering workflow\n\n\n::: {.cell hash='netAnaR_cache/revealjs/cluster_ex_55bf20939e3d617bf025ebce94c30861'}\n\n```{.r .cell-code}\n# compute clustering\nclu <- cluster_louvain(karate)\n\n# cluster membership vector\nmem <- membership(clu)\nmem\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 1 1 2 2 2 1 3 3 2 1 1 1 3 3 2 1 3 1 3 1 3 3 4 4 3 3 4 3 3 4 3 3\n```\n:::\n\n```{.r .cell-code}\n# clusters as list\ncom <- communities(clu)\ncom\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$`1`\n [1]  1  2  3  4  8 12 13 14 18 20 22\n\n$`2`\n[1]  5  6  7 11 17\n\n$`3`\n [1]  9 10 15 16 19 21 23 24 27 28 30 31 33 34\n\n$`4`\n[1] 25 26 29 32\n```\n:::\n:::\n\n\n## Clustering workflow\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/karate_cluster_2c4e77a80fe04fa39638606e961fec21'}\n\n```{.r .cell-code}\nimc <- cluster_infomap(karate)\nlec <- cluster_leading_eigen(karate)\nloc <- cluster_louvain(karate)\nsgc <- cluster_spinglass(karate)\nwtc <- cluster_walktrap(karate)\n\nscores <- c(infomap = modularity(karate,membership(imc)),\n            eigen = modularity(karate,membership(lec)),\n            louvain = modularity(karate,membership(loc)),\n            spinglass = modularity(karate,membership(sgc)),\n            walk = modularity(karate,membership(wtc)))\n\nscores\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  infomap     eigen   louvain spinglass      walk \n 0.402038  0.393409  0.418803  0.418803  0.353222 \n```\n:::\n:::\n\n\n## Cluster workflow\n\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/karate_plot_clu_fba1bad053d37bf4af0f3f3373fcda12'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/karate_plot_clu-1.png){fig-align='center' width=960}\n:::\n:::\n\n# Beyond \"standard\" networks\n\n## Two-mode networks\n\nA **two-mode network** is a network that consists of two disjoint sets of nodes (like people and events)\n\nCommon examples include:   \n\n- Affiliation networks (Membership in institutions)\n- Voting/Sponsorship networks (politicians and bills)\n- Citation network (authors and papers)\n- Co-Authorship networks (authors and papers)\n\n## Toy example\n\n\n::: {.cell hash='netAnaR_cache/revealjs/southern_dat_load_4446ad4bb304b8d184ec1c798b385cfb'}\n\n```{.r .cell-code}\ndata(\"southern_women\")\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/southern_women_ac7e40ddbb5ed79be1d5720f472a16bc'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/southern_women-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Analyzing two-mode networks \n\n<br>\n\nThe adjacency matrix is called **incidence matrix**\n\n\n::: {.cell hash='netAnaR_cache/revealjs/incidence_southern_ef0bf96b579a46bd3d27990882fe63e3'}\n\n```{.r .cell-code}\nA <- as_incidence_matrix(southern_women)\nA[1:8, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          6/27 3/2 4/12 9/26 2/25 5/19 3/15 9/16 4/8 6/10 2/23 4/7 11/21 8/3\nEVELYN       1   1    1    1    1    1    0    1   1    0    0   0     0   0\nLAURA        1   1    1    0    1    1    1    1   0    0    0   0     0   0\nTHERESA      0   1    1    1    1    1    1    1   1    0    0   0     0   0\nBRENDA       1   0    1    1    1    1    1    1   0    0    0   0     0   0\nCHARLOTTE    0   0    1    1    1    0    1    0   0    0    0   0     0   0\nFRANCES      0   0    1    0    1    1    0    1   0    0    0   0     0   0\nELEANOR      0   0    0    0    1    1    1    1   0    0    0   0     0   0\n [ reached getOption(\"max.print\") -- omitted 1 row ]\n```\n:::\n:::\n\n\n{{< CRAN tnet >}} and {{< CRAN bipartite >}}  offer some methods to analyse two mode networks **directly**, by adapting tools for standard networks.\n\n## Projecting two-mode networks\n\n![](img/small_project.png)\n\n\n::: {.cell hash='netAnaR_cache/revealjs/proj_women_d4e98d770719fb9f59770cb71a4a9c6d'}\n\n```{.r .cell-code}\nB <- A%*%t(A)\nB[1:5,1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          EVELYN LAURA THERESA BRENDA CHARLOTTE\nEVELYN         8     6       7      6         3\nLAURA          6     7       6      6         3\nTHERESA        7     6       8      6         4\nBRENDA         6     6       6      7         4\nCHARLOTTE      3     3       4      4         4\n```\n:::\n:::\n\n\n## Projecting two-mode networks\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/plot_weighted_proj_2dc0628067ef95ea39f1a658fdae8dc4'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/plot_weighted_proj-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Filtering projections\n\n![](img/proj_flow.png)\n\n**naïve**  \ndelete all edge with a weight less than x\n\n**advanced**  \nstatistical tools using null models: {{< CRAN backbone >}}  \n[Introduction to the package](https://arxiv.org/abs/1912.12779)\n\n## \"Backbone\" null models\n\nCompare an edge's observed weight in the projection to the distribution of weights expected in a projection obtained from a random bipartite network where both the row vertex degrees and column vertex degrees are ...\n\n**Fixed degree sequence model**  \n... *exactly* fixed at their original values\n\n**Stochastic degree sequence model**  \n... *approximately* fixed at their original values\n\n## \"Backbone\" example\n\n\n::: {.cell hash='netAnaR_cache/revealjs/southern_backbone_56f3ea772076186f68627ed6c36bd53e'}\n\n```{.r .cell-code}\nlibrary(backbone)\nsw_bb <- sdsm(southern_women,alpha = 0.4)\n```\n:::\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/sw_bb_plot_dca1c207d14938fed517454eeb55f1a2'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/sw_bb_plot-1.png){fig-align='center' width=1152}\n:::\n:::\n\n\n\n## Application of projections\n\n**Co-voting behavior of US senators**\n\n![](img/senate.jpg)\n\n[Link to paper](https://www.nature.com/articles/s41598-020-74175-w)\n\n\n## Signed networks\n\n<br>\n\nSigned networks include two types of relations:  \npositive (\"friends\") and negative (\"foes\")\n\ntypical research questions involve (implemented in {{< CRAN signnet >}}):\n\n- structural balance\n- blockmodeling\n- (centrality)\n\n## Structural balance theory\n<br>\n\n**developed by Heider in 1940s**:  \n\n- mental discomfort when actors hold contradictory beliefs\n- there is a preference for ’balance’ (consistency) states\n- states of imbalance and mental discomfort create ’tension’\n- imbalanced states are unstable\n- imbalanced states move towards balance\n\n**formalised with graph theory by Cartwright Harary (1950s)**\n\n## Structural balance theory\n\n:::{.center-x}\n![](img/balance_triples.png){width=\"900\"}\n:::\n\n**Beyond triangles**  \nA network is balanced if it can be partitioned into two groups such that all intra group edges are positive and all inter group edges are negiative\n\n**Extended form of balance** (Davis 1960s)  \nA network is balanced if it can be partitioned into k groups ...\n\n\n## Toy example\n\n<br>\n\n\n::: {.cell hash='netAnaR_cache/revealjs/sign example_84047e2d01e4e391fb1029c93e3f7d43'}\n\n```{.r .cell-code}\nlibrary(signnet)\ndata(\"tribes\")\n```\n:::\n\n\n:::{.columns}\n:::{.column width=\"49%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/tribes_now_2b2710bc45f8e8d6f5329818910a781b'}\n\n```{.r .cell-code}\nggsigned(tribes)\n```\n\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/tribes_now-1.png){width=960}\n:::\n:::\n\n:::\n\n:::{.column width=\"49%\"}\n\n::: {.cell hash='netAnaR_cache/revealjs/tribes_w_c0fba6bac2da6338ece045e77585879d'}\n\n```{.r .cell-code}\nggsigned(tribes,weights = T)\n```\n\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/tribes_w-1.png){width=960}\n:::\n:::\n\n:::\n:::\n\n## Measuring structural balance\n\n- **triangles**: Fraction of balanced triangles. \n- **walks**: fraction of signed to unsigned walks\n- **frustration**: optimal partition such that the sum of intra group negative and inter group positive edges is minimized\n\n\n::: {.cell hash='netAnaR_cache/revealjs/balance_scores_7a946cc43f382a2e87df5b25930235f6'}\n\n```{.r .cell-code}\nbalance_score(tribes,method = \"triangles\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.867647\n```\n:::\n\n```{.r .cell-code}\nbalance_score(tribes,method = \"walk\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.357576\n```\n:::\n\n```{.r .cell-code}\nbalance_score(tribes,method = \"frustration\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.758621\n```\n:::\n:::\n\n\n\n## Blockmodeling\n\nIn signed blockmodeling, the goal is to determine $k$ blocks of nodes such that all intra-block edges are positive and inter-block edges are negative\n\n\n::: {.cell hash='netAnaR_cache/revealjs/signed_bm_f159ea023be384b758f917981c3fa7d7'}\n\n```{.r .cell-code}\nset.seed(141)\nbl <- signed_blockmodel(tribes,3)\nbl\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$membership\n [1] 3 3 1 1 2 1 1 1 2 2 1 1 2 2 3 3\n\n$criterion\n[1] 2\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\" output-location='slide' hash='netAnaR_cache/revealjs/signed_bm_plot_09a05e714668372e274c2d90879e105b'}\n\n```{.r .cell-code}\nggblock(tribes,blocks = bl$membership,show_blocks = TRUE,show_labels = TRUE)\n```\n\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/signed_bm_plot-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n## Generalized blockmodeling\n\nThe diagonal block structure is not always the most optimal representaion of the data\n\n::: {.cell layout-align=\"center\" hash='netAnaR_cache/revealjs/weird_signed_56a03f1be965f8e216ead3343ec00dde'}\n::: {.cell-output-display}\n![](netAnaR_files/figure-revealjs/weird_signed-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## Generalized blockmodeling\n\nThe function `signed_blockmodel_general()` allows to specify arbitrary block structures.\n\n::: {.cell hash='netAnaR_cache/revealjs/gen_block_mat_6f5bf5ce499324c5b78d43ed5fbfa6ac'}\n\n```{.r .cell-code}\nset.seed(424) #for reproducibility\nblockmat <- matrix(c(1,-1,-1,-1,1,1,-1,1,-1),3,3,byrow = TRUE)\nblockmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    1   -1   -1\n[2,]   -1    1    1\n[3,]   -1    1   -1\n```\n:::\n\n```{.r .cell-code}\ngeneral <- signed_blockmodel_general(g,blockmat,alpha = 0.5)\ntraditional <- signed_blockmodel(g,k = 3,alpha = 0.5,annealing = TRUE)\n\nc(general$criterion,traditional$criterion)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0 6\n```\n:::\n:::\n\n\n## Generalized blockmodeling\n:::{.center-x}\n![](img/blockmodel_general.png){width=\"750\"}\n:::\n\n## Other functions\n\nMost functions us the igraph name + `_signed`:\n\n- `as_adj_signed()`\n- `as_incidence_signed()`\n- `laplacian_matrix_signed()`\n- `triad_census_signed()`\n- `degree_signed()`\n- `eigen_centrality_signed()`\n- `sample_islands_signed()`\n\n## All signed triads\n\n:::{.center-x}\n![](img/signed_triads.png){width=\"600\"}\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}