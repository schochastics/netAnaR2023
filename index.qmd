---
title: "Network Analysis in R"
subtitle: ""
author: "David Schoch"
footer: "Workshop series for Ukraine {{< fa brands r-project >}}"
institute: "GESIS - Leibniz Institute for the Social Sciences"
shortcodes:
  - misc.lua
format: 
  revealjs: 
    menu: true
    progress: false
    theme: "schochastics.scss"
    slide-number: c/t
    show-slide-number: all
    code-line-numbers: false
execute: 
  cache: true
  echo: true
---
```{r}
#| echo: false
#| warning: false
#| message: false
#| label: setup

library(ggraph)
library(igraph)
library(networkdata)
library(netrankr)

library(kableExtra)
library(ggplot2)
library(graphlayouts)

# base colors
bg_col <- "#333333"
main_col <- "#9EEBCF"
text_col <- "white"
highlight_col <- "#ffd700"
```

:::{.center-x}
![](img/qr-code.png){width="400"}  
<https://schochastics.github.io/netAnaR2023>
:::

## My R universe

<img src="img/hex_bg.png" width="400">

## My R universe

<img src="img/hex_net_bg.png" width="605">

# A Short Introduction to Network Analysis


## Why study networks?
conventional research methods are often individual based
and our models tend to model relations between variables

:::{.fragment}
**but nature and culture is structured as networks**
:::

:::{.fragment}
- **society**
- brain (neural networks)
- organizations (who reports to whom)
- economies (who sells to whom)
- ecologies (who eats whom)
:::

:::{.fragment}
**Position within a network is important for predicting outcomes**
:::

## From "ordinary" to network data

<br>

:::{.fragment}
**atomic data**  
individuals or entities
:::

:::{.fragment}
**dyadic data**  
dependent pairs of individuals (e.g. couples)  
but treated as independent entities
:::

:::{.fragment}
**networks**  
interdependent and overlapping dyads    
usual (statistical) independence assumptions do not hold
:::

## Levels of Analysis

<br>

:::{.fragment}
**dyad level**  
Fundamental unit of network data collection  
("Does sharing offices lead to friendship?") 
:::

:::{.fragment}
**node level**  
Aggregation of dyad level measurement  
("Do actors with more friends have a stronger immune system?")
:::

:::{.fragment}
**network level**  
Assessing overal structure of a network  
("Do well connected networks diffuse ideas faster?")
:::

:::{.fragment .text08}
more levels are possible (triads, groups, ...)
:::

## Types of relations I

<br>

:::{.fragment}
**Relational states**  

- Similarities: location, participation, attribute  
- Relational roles: kinship, other roles  
- Relational cognition: affective, perceptual
:::

:::{.fragment}
**Relational events**  

- Interactions: sold to, talked to, helped, ...
- Flows: information, belief, money
:::

## Types of relations II

<br>

:::{.fragment}
**undirected**  
symmetric relation
:::

:::{.fragment}
**directed**  
asymmetric relation, but can be bi-directional
:::

:::{.fragment}
**valued**  
strength of relation, frequency of contact, etc.
:::

:::{.fragment}
**signed**  
positive and negative relations
:::

:::{.fragment}
**or a mixture thereof**
:::

## Goals of analysis

:::{.fragment}
**Network variables as independent/explanatory**  

> *Using network theory to explain the consequences of network properties*

social capital, brokerage, adoption of innovation
:::

:::{.fragment}
**Network variables as dependent/outcomes**  

> *Using ______ theory to explain the antecendents of a network*

homophily, balance theory
:::


# R Ecosystem for Network Analysis

##

:::{.center-x}
![](img/tidyverse-meme.jpg)
:::


## What is "base R" for networks?

```{r}
#| label: cranet
#| echo: false
#| fig-cap: "CRAN dependencies on igraph, graph, network" 
g <- readRDS("dependnet.RDS")
ggraph(g, "stress") +
    geom_edge_link0(
        edge_color = "grey66", edge_width = 0.3,
        arrow = arrow(
            angle = 15, length = unit(0.15, "inches"),
            ends = "last", type = "closed"
        )
    ) +
    geom_node_point(shape = 21, aes(fill = dep, size = seed)) +
    scale_fill_brewer(type = "qual", name = "") +
    scale_size_manual(values = c(2, 5), guide = "none") +
    guides(fill = guide_legend(override.aes = list(size = 5))) +
    theme_void() +
    theme(legend.position = "bottom") +
    coord_equal(clip = "off")

```


## Which package to choose?

<br>

use `igraph` if

- you need speed (large networks)
- you need to use other SNA packages

:::{.fragment}
use `network`/`sna` if

- you need to do modeling (e.g. ERGMs and RSIENA)
:::

:::{.fragment}
**does not make a difference in most cases, never load them both!**
:::

## Creating simple networks

```{r make_graph}
g1 <- make_graph(c(1,2, 1,3, 2,3, 2,4, 3,5, 4,5), n = 5, dir = FALSE)
g2 <- graph_from_literal(Joey-Chandler:Monica-Ross, Joey-Ross-Rachel)
```
:::: {.columns}
::: {.column width="50%"}
```{r make_graph_lot}
#| echo: false
#| fig.width: 4
#| fig.height: 4
V(g1)$name <- 1:5
ggraph(g1,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  geom_node_text(aes(label=name))+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="50%"}

```{r make_literal_lot}
#| echo: false
#| fig.width: 4
#| fig.height: 4

ggraph(g2,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  geom_node_text(aes(label=name))+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::::

## Special graphs

```{r make_examples}
g3 <- make_full_graph(n = 10)
g4 <- make_ring(n = 10)
g5 <- make_empty_graph(n = 10)
```

:::: {.columns}
::: {.column width="33%"}
```{r full_graph_plot}
#| echo: false
#| fig.width: 3
#| fig.height: 3
ggraph(g3,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="33%"}

```{r ring_plot}
#| echo: false
#| fig.width: 3
#| fig.height: 3

ggraph(g4,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="33%"}

```{r empty_plot}
#| echo: false
#| fig.width: 3
#| fig.height: 3

ggraph(g5,"nicely") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::


::::

```{r igraph_make}
#| eval: false
ls("package:igraph",pattern = "make_*")
```

## Random graphs

```{r make_randoms}
g6 <- sample_gnp(n = 100,p = 0.1)
g7 <- sample_pa(n = 100, power = 1.5, m = 1, directed = FALSE)
```

:::: {.columns}
::: {.column width="50%"}
```{r er_plot}
#| echo: false
#| fig.width: 4
#| fig.height: 4
ggraph(g6,"stress") + 
  geom_edge_link0(edge_width=0.5,edge_color="grey66") +
  geom_node_point(shape=21,size=3,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="50%"}

```{r pa_plot}
#| echo: false
#| fig.width: 4
#| fig.height: 4

ggraph(g7,"stress") + 
  geom_edge_link0(edge_width=0.5,edge_color="grey66") +
  geom_node_point(shape=21,size=2,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::
::::

```{r igraph_sample}
#| eval: false
ls("package:igraph",pattern = "sample_*")
```

## igraph objects 


```{r igraph_obj}
g2
```

<br>

```{r str_igraph}
library(netUtils)
str(g2)
```

## Attributes

**node attributes**
```{r vadd_attr}
V(g2)$name
V(g2)$gender <- c("M","M","F","M","F") 
# g2 <- set_vertex_attr("gender", c("M","M","F","M","F"))
```
. . .

**edge attributes**

```{r eadd_attr}
E(g2)
E(g2)$weight <- sample(1:5,size = 6, replace = TRUE)
# g2 <- set_edge_attr("weight", sample(1:5,size = 6, replace = TRUE))
```

## Attributes

```{r igraph_obj1}
g2
```

<br>

```{r str_igraph1}
str(g2)
```

## Network representations: adjacency matrix

```{r adj_mat}
A <- matrix(
  c(0, 1, 1,
    1, 0, 1,
    1, 1, 0),
  nrow = 3, ncol = 3, byrow = TRUE)
rownames(A) <- c("Bob","Ann","Steve")
colnames(A) <- c("Bob","Ann","Steve")
A
```

- $A_{ij}=1$ if there is an edge between $i$ and $j$
- $A$ is symmetric for undirected networks 
- If $A_{ij}>1$ then the values are interpreted as weights 

## Network representation: edgelist

<br>

```{r edge_lst}
el <- matrix(
  c("Bob","Ann",
    "Bob","Steve",
    "Ann","Steve"),
  nrow = 3,ncol = 2, byrow = TRUE)
el
```

more efficient for sparse data (null edges aren't stored)

## Networks from matrices and lists

**adjacency matrix**
```{r from_adj}
graph_from_adjacency_matrix(
  A,
  mode = "undirected",
  weighted = NULL,
  diag = FALSE)
```

**edgelist**
```{r from_edgelist}
graph_from_edgelist(el, directed = FALSE)
```

```{r graph_from}
#| eval: false
ls("package:igraph",pattern = "graph_from_*")
```

## Reading network data

<br>

:::{.fragment}
**Data is already in R (e.g. `networkdata`)**  
No extra work
:::

:::{.fragment}
**Data was processed in another SNA tool**  
```{r read_graph}
#| eval: false
read_graph(file, format = c("edgelist", "pajek", "ncol", "lgl",
  "graphml", "dimacs", "graphdb", "gml", "dl"), ...)
```
Some extra work (with some issues) 
:::

:::{.fragment}
**Data is in a csv/spreadsheet/..**  
`read.table()`, `read.csv()`, {{< CRAN readxl >}}, {{< CRAN readr >}},...
:::

## Preparing network data with attributes {.smaller}

**Organize network data in two separate files**

::::{.columns}
:::{.column width="50%"}
```{r el_df}
#| echo: false
data("greys")
head(igraph::as_data_frame(greys)) |> knitr::kable()
```
:::
:::{.column width="50%"}
```{r node_df}
#| echo: false
head(igraph::as_data_frame(greys,what = "vertices")[,c(1,2,4)]) |> 
  knitr::kable(row.names=FALSE)
```
:::
:::

<br>

```{r df1}
#| eval: false
graph_from_data_frame(el, directed = c(TRUE, FALSE), vertices)
```

# Descriptive Statistics and some graph theory

## Toy example
```{r load_greys}
data("greys")
```


```{r plot_greys}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
ggraph(greys,"stress",bbox=10) + 
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,aes(fill=sex),size=5,show.legend = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE)+
  scale_fill_manual(values=c("grey66","#E8813A","#4D189D"))+
  theme_void()
```

## Density

<br>

The **density** of a network is defined as the fraction of the potential edges in a network that are actually present.
```{r density}
c(graph.density(make_empty_graph(10)), 
  graph.density(greys), 
  graph.density(make_full_graph(10)))
```

## Shortest Paths

A **shortest path** is a path that connects two nodes in a network with a minimal number of edges. The length of a shortest path is called the distance between two nodes.

```{r shortest_path}
shortest_paths(greys,from = "Alex Karev",to = "Owen Hunt",output = "vpath")
```

## Shortest Paths
```{r greys_shortest_path}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
E(greys)$epath <- FALSE
E(greys)$epath[as.integer(shortest_paths(greys,from = "Alex Karev",to = "Owen Hunt",output = "epath")$epath[[1]])] <- TRUE

ggraph(greys,"stress",bbox=10) + 
  geom_edge_link0(aes(color=epath,width=epath),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=sex),size=5,show.legend = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE)+
  scale_fill_manual(values=c("grey66","#E8813A","#4D189D"))+
  scale_edge_color_manual(values=c("grey66","firebrick3"))+
  scale_edge_width_manual(values=c(0.5,1.5))+
  theme_void()

```

## Distances

```{r distances}
distances(greys)[1:5,1:5]
```

The Grey's Anatomy network is **disconnected** ($4$ **connected components**)

## Diameter

The length of the longest shortest path is called the **diameter** of the network.

```{r diameter}
diameter(greys)
```

```{r greys_diameter}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
E(greys)$epath <- FALSE
E(greys)$epath[as.integer(shortest_paths(greys,from = "Finn Dandridge",to = "Colin Marlow",output = "epath")$epath[[1]])] <- TRUE

ggraph(greys,"stress",bbox=10) + 
  geom_edge_link0(aes(color=epath,width=epath),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=sex),size=5,show.legend = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE)+
  scale_fill_manual(values=c("grey66","#E8813A","#4D189D"))+
  scale_edge_color_manual(values=c("grey66","firebrick3"))+
  scale_edge_width_manual(values=c(0.5,1.5))+
  theme_void()

```

## Transitivity

**Transitivity** is a measure of the degree to which nodes in a graph tend to cluster together. This is also called the **clustering coefficient**. 

**local**  
gives an indication of the embeddedness of single nodes

```{r ccoef_example}
#| echo: false
#| fig.width: 15
#| fig.height: 5
#| fig.align: center
library(patchwork)
g1 <- make_full_graph(4)
V(g1)$focal <- FALSE
V(g1)$focal[1] <- TRUE
E(g1)$from1 <- FALSE
E(g1)$from1[incident_edges(g1,1)[[1]]] <- TRUE
xy <- graphlayouts::layout_with_stress(g1)
xy <- graphlayouts::layout_rotate(xy,20)
p1 <- ggraph(g1, "manual",x = xy[,1],y = xy[,2]) + 
  geom_edge_link0(aes(edge_width=from1,edge_color=from1),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=focal),show.legend = FALSE,size=15,stroke=1.5)+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_edge_width_manual(values=c(2,0.5))+
  scale_edge_color_manual(values=c("grey25","grey66")) + 
  theme_graph()+
  coord_cartesian(clip = "off")

g2 <- delete.edges(g1,c(4,6))
p2 <- ggraph(g2, "manual",x = xy[,1],y = xy[,2]) + 
  geom_edge_link0(aes(edge_width=from1,edge_color=from1),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=focal),show.legend = FALSE,size=15,stroke=1.5)+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_edge_width_manual(values=c(2,0.5))+
  scale_edge_color_manual(values=c("grey25","grey66")) + 
  theme_graph()+
  coord_cartesian(clip = "off")

g3 <- delete.edges(g1,c(4,5,6))
p3 <- ggraph(g3, "manual",x = xy[,1],y = xy[,2]) + 
  geom_edge_link0(aes(edge_width=from1,edge_color=from1),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=focal),show.legend = FALSE,size=15,stroke=1.5)+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_edge_width_manual(values=c(0.5,0.5))+
  scale_edge_color_manual(values=c("grey66","grey66")) + 
  theme_graph()+
  coord_cartesian(clip = "off")

p1 + p2 + p3

```

:::: {.columns}

::: {.column width="65%"}
**global**  
indication of the clustering in the network
:::

::: {.column width="35%"}
$$
\frac{3 \times \text{number of triangles} }{\text{total number of triplets}}
$$

:::

::::

## Transitivity
```{r transitivity}
data("coleman")
g <- as.undirected(coleman[[1]])
transitivity(g, type = "global")
```

```{r transitivity2}
transitivity(g, type = "local", isolates = "zero")
```

<br>

In empirical networks, we often observe a tendency towards high transitivity ("the friend of a friend is a friend")  

## Degree distribution

<br>

The **degree** of a node in a network is the number of connections it has to other nodes.

The **degree distribution** is the probability distribution of the degrees over the whole network.

Empirical degree distributions are generally right skewed.  
(Many nodes have a few conncetions and few have many)
"preferential attachment", "matthew effect", "the rich get richer"  

## Degree distribution

<br>

```{r deg_dist_graphs}
er <- sample_gnp(n = 5000, p = 0.01)
pa <- sample_pa(n = 5000, power = 1.5, m = 2, directed = FALSE)
```

<br>

:::: {.columns}

::: {.column width="50%"}

```{r dd_er}
plot(degree_distribution(er))
```

:::

::: {.column width="50%"}

```{r dd_pa}
plot(degree_distribution(pa),log = "xy")
```

:::

::::

## Centrality

A **measure of centrality** is an index that assigns a numeric values to
the nodes of the network. The higher the value, the more central the node. 

"Being central" is a very ambiguous term hence there exists a large variety of indices that assess centrality with very different structural properties.

```{r star_net}
#| echo: false
#| fig.align: center
#| fig.width: 4
#| fig.height: 4
g<-graph.star(8,"undirected")
V(g)$center <- c(T,rep(F,7))
ggraph(g,"stress") + 
  geom_edge_link0(edge_width = 2,edge_color="white")+
  geom_node_point(shape=21,aes(fill=center,size=center),color="white") + 
  theme_graph(background = "#333333")+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_size_manual(values=c(7,14))+
  theme(legend.position = "none")
```


##

```{r periodic}
#| echo: false
knitr::include_graphics("img/periodic_table.png")
```

## Standard indices {.text09}

**Degree**  
Number of direct neighbors ("popularity")  

**Closeness**  
Reciprocal of the sum of the length of the shortest paths

**Betweenness**  
Number of shortest paths that pass through a node ("brokerage")

**Eigenvector**  
Being central means being connected to other central nodes

**PageRank**  
Similar to eigenvector, just for directed networks 

## Implemented indices {.smaller}

`igraph` contains the following 10 indices:

- [degree (`degree()`)]{.highlight}
- [weighted degree (`strength()`)]{.highlight}
- [betweenness (`betweenness()`)]{.highlight}
- [closeness (`closeness()`)]{.highlight}
- [eigenvector (`eigen_centrality()`)]{.highlight}
- alpha centrality (`alpha_centrality()`)
- power centrality (`power_centrality()`)
- [PageRank (`page_rank()`)]{.highlight}
- eccentricity (`eccentricity()`)
- hubs and authorities (`authority_score()` and `hub_score()`)
- subgraph centrality (`subgraph_centrality()`)

## Indices in the sna package

The `sna` package implements roughly the same indices as but adds:

- flow betweenness (`flowbet()`)
- load centrality (`loadcent()`)
- Gil-Schmidt Power Index (`gilschmidt()`)
- information centrality (`infocent()`)
- stress centrality (`stresscent()`)

## Dedicated packages

{{< CRAN centiserve >}}, {{< CRAN CINNA >}}  
```{r centiserve}
library(centiserve)
as.character(lsf.str("package:centiserve"))
```

[centiserver](http://www.centiserver.org/) lists more than 400 indices

CINNA:  
Computing and comparing top informative centrality measures 

## Alternatives?

{{< CRAN netrankr >}}:  
Tools which allow an indexfree assessment of centrality, including:  

- partial centrality
- expected centrality
- probabilistic centrality

:::{.callout-tip}
## Help

Tutorials and material for using netrankr can be found at [https://schochastics.github.io/netrankr/](https://schochastics.github.io/netrankr/)

:::

## Cohesive groups

Cohesive subgroups are subsets of actors among whom there are relatively strong, direct, intense, frequent, or positive ties. 

Methods that formalize the intuitive and theoretical notion of social group using social network properties

:::{.center-x}
![](img/cohesive.png){width="950"}
:::

## Cliques

A *clique* in a network is a set of nodes that form a complete subnetwork within a network (called a complete **subgraph**). 

A **maximal clique** is a clique that cannot be extended to a bigger clique by addding more nodes to it. 

```{r load_clique_graph}
data("clique_graph")
```

```{r clique_graph}
#| echo: false
#| fig.align: center
ggraph(clique_graph,"stress") +
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=8,fill="grey25")+
  theme_graph()
```

## Cliques

Maximal cliques can be calculated with `max_cliques()` 
```{r calc_max_cliques}
# only return cliques with three or more nodes
cl <- max_cliques(clique_graph,min = 3)
cl
```

## Cliques


```{r clique_graph_2}
#| echo: false
#| fig.align: center

xy <- graphlayouts::layout_with_stress(clique_graph)

cl_df <- as.data.frame(do.call("rbind",
  lapply(seq_along(cl),function(x){
    cbind(xy[cl[[x]],],x)
  })
))

ggraph(clique_graph,"stress") +
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=8,fill="grey25")+
  ggforce::geom_mark_hull(data = cl_df,aes(V1,V2,fill=as.factor(x),group=x),show.legend = FALSE)+
  scale_fill_manual(values=c("#E69F00", "#000000", "#56B4E9", "#009E73", "#F0E442", "#0072B2", 
                             "#D55E00", "#CC79A7", "#666666"))+
  theme_void()
```

## k-core decomposition

A **k-core** is a subgraph in which every node has at least k neighbors within the subgraph. A k-core is thus a relaxed version of a clique.  

```{r kcore}
kcore <- coreness(clique_graph)
kcore
```

```{r kcore_plot}
#| echo: false
#| fig.align: center
cl_df <- as.data.frame(do.call("rbind",
  lapply(sort(unique(kcore))[c(2,3,4)],function(x){
    cbind(xy[kcore>=x,],x)
    })
))

ggraph(clique_graph,"stress") +
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape = 21,size = 8,fill="grey25")+
  ggforce::geom_mark_hull(data = cl_df,aes(V1,V2,fill=as.factor(x),group=x),show.legend = FALSE)+
  scale_fill_manual(values=c("red","blue","green"))+
  theme_void()

```

## Clustering/Community detection

**Minimum-cut method**  
cut graph into partitions which minimizes some metric

**Hierarchical clustering**  
Agglomerative/Divisive methods to build a hierarchy of clusters  
based on node similarity

**Modularity Maximization**  
Modularity is defined as the fraction of edges that fall within given groups minus the expected fraction if edges were random

**Statistical inference**  
[stochastic blockmodeling](https://graph-tool.skewed.de/) based on generative models

## Clustering with igraph

<br>

- There is no agreed upon best method
- Modularity maximization is still widely considered "state-of-the-art"
- Generative models are, however, a strong contender  
  (not implemented in R yet)

```{r cluster_alg}
ls("package:igraph",pattern = "cluster_")
```

## Clustering workflow

```{r karate}
data("karate")
```

```{r karate_plot}
#| echo: false
#| fig.align: center
ggraph(karate,"stress")+
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=5,fill="grey66")+
  theme_void()+
  coord_equal()
```

## Clustering workflow

```{r cluster_ex}
# compute clustering
clu <- cluster_louvain(karate)

# cluster membership vector
mem <- membership(clu)
mem

# clusters as list
com <- communities(clu)
com
```

## Clustering workflow

<br>

```{r karate_cluster}
imc <- cluster_infomap(karate)
lec <- cluster_leading_eigen(karate)
loc <- cluster_louvain(karate)
sgc <- cluster_spinglass(karate)
wtc <- cluster_walktrap(karate)

scores <- c(infomap = modularity(karate,membership(imc)),
            eigen = modularity(karate,membership(lec)),
            louvain = modularity(karate,membership(loc)),
            spinglass = modularity(karate,membership(sgc)),
            walk = modularity(karate,membership(wtc)))

scores
```

## Clustering workflow

```{r karate_plot_clu}
#| echo: false
#| fig.align: center
V(karate)$clu <- membership(sgc)
ggraph(karate,"stress")+
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=5,aes(fill=as.factor(clu)),show.legend=FALSE)+
  theme_void()+
  coord_equal()
```
# Beyond "standard" networks

## Two-mode networks

A **two-mode network** is a network that consists of two disjoint sets of nodes (like people and events)

Common examples include:   

- Affiliation networks (Membership in institutions)
- Voting/Sponsorship networks (politicians and bills)
- Citation network (authors and papers)
- Co-Authorship networks (authors and papers)

## Toy example

```{r southern_dat_load}
data("southern_women")
```

```{r southern_women}
#| echo: false
#| fig.align: center
ggraph(southern_women,"stress")+
  geom_edge_link(edge_color="grey66")+
  geom_node_point(aes(fill=type,shape=type),size=8,show.legend = FALSE)+
  geom_node_text(aes(label=name))+
  scale_shape_manual(values=c(21,22))+
  theme_void()

```

## Analyzing two-mode networks 

<br>

The adjacency matrix is called **incidence matrix**

```{r incidence_southern}
A <- as_incidence_matrix(southern_women)
A[1:8, ]
```

{{< CRAN tnet >}} and {{< CRAN bipartite >}}  offer some methods to analyse two mode networks **directly**, by adapting tools for standard networks.

## Projecting two-mode networks

![](img/small_project.png)

```{r proj_women}
B <- A%*%t(A)
B[1:5,1:5]
```

## Projecting two-mode networks
```{r plot_weighted_proj}
#| echo: false
#| fig.align: center

proj <- graph_from_adjacency_matrix(B,weighted = TRUE,diag = FALSE,mode = "undirected")

ggraph(proj,"stress")+
  geom_edge_link(aes(edge_width=weight),edge_color="grey66",show.legend = FALSE)+
  geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
  geom_node_text(aes(label=name))+
  scale_edge_width(range = c(1,4))+
  theme_void()+
  coord_cartesian(clip = "off")

```

## Filtering projections

![](img/proj_flow.png)

**naïve**  
delete all edge with a weight less than x

**advanced**  
statistical tools using null models: {{< CRAN backbone >}}  
[Introduction to the package](https://arxiv.org/abs/1912.12779)

## Signed networks

<br>

Signed networks include two types of relations:  
positive ("friends") and negative ("foes")

typical research questions involve (implemented in {{< CRAN signnet >}}):

- structural balance
- blockmodeling
- (centrality)

## Structural balance theory

:::{.center-x}
![](img/balance_triples.png){width="900"}
:::

**Beyond triangles**  
A network is balanced if it can be partitioned into two groups such that all intra group edges are positive and all inter group edges are negiative

**Extended form of balance** (Davis 1960s)  
A network is balanced if it can be partitioned into k groups ...


## Toy example

<br>

```{r sign example}
library(signnet)
data("tribes")
```

:::{.columns}
:::{.column width="49%"}
```{r tribes_now}
ggsigned(tribes)
```
:::

:::{.column width="49%"}
```{r tribes_w}
ggsigned(tribes,weights = TRUE)
```
:::
:::

## Measuring structural balance

- **triangles**: Fraction of balanced triangles. 
- **walks**: fraction of signed to unsigned walks
- **frustration**: optimal partition such that the sum of intra group negative and inter group positive edges is minimized

```{r balance_scores}
balance_score(tribes,method = "triangles")
balance_score(tribes,method = "walk")
balance_score(tribes,method = "frustration")
```


## Blockmodeling

In signed blockmodeling, the goal is to determine $k$ blocks of nodes such that all intra-block edges are positive and inter-block edges are negative

```{r signed_bm}
set.seed(141)
bl <- signed_blockmodel(tribes,3)
bl
```

```{r signed_bm_plot}
#| fig.align: center
#| fig.width: 6
#| fig.height: 6
#| output-location: slide
ggblock(tribes,blocks = bl$membership,show_blocks = TRUE,show_labels = TRUE)
```

## Generalized blockmodeling

The diagonal block structure is not always the most optimal representaion of the data
```{r weird_signed}
#| echo: false
#| fig.height: 5
#| fig.width: 10
#| fig.align: center
library(patchwork)
g1 <- g2 <- g3 <- graph.full(5)

V(g1)$name <- as.character(1:5)
V(g2)$name <- as.character(6:10)
V(g3)$name <- as.character(11:15)

g <- Reduce("%u%",list(g1,g2,g3))
E(g)$sign <- 1
E(g)$sign[1:10] <- -1
g <- add.edges(g,c(rbind(1:5,6:10)),attr = list(sign=-1))
g <- add.edges(g,c(rbind(1:5,11:15)),attr = list(sign=-1))
g <- add.edges(g,c(rbind(11:15,6:10)),attr = list(sign=1))

p1<-ggsigned(g,weights = FALSE)
p2<-ggblock(g,rep(1:3,each=5),show_blocks = TRUE)
p1+p2
```

## Generalized blockmodeling

The function `signed_blockmodel_general()` allows to specify arbitrary block structures.
```{r gen_block_mat}
set.seed(424) #for reproducibility
blockmat <- matrix(c(1,-1,-1,-1,1,1,-1,1,-1),3,3,byrow = TRUE)
blockmat

general <- signed_blockmodel_general(g,blockmat,alpha = 0.5)
traditional <- signed_blockmodel(g,k = 3,alpha = 0.5,annealing = TRUE)

c(general$criterion,traditional$criterion)
```

## Generalized blockmodeling
:::{.center-x}
![](img/blockmodel_general.png){width="750"}
:::

# Is there a "tidyverse" for networks?


## tidygraph I

> This package provides a tidy API for graph/network manipulation. While network data itself is **not tidy**, it can be envisioned as **two tidy tables**, one for node data and one for edge data. tidygraph provides a way to switch between the two tables and provides `dplyr` verbs for manipulating them.


##
:::{.center-x}
![](img/tidygraph-meme.jpg)
:::

## tidygraph II

> It more or less wraps the full functionality of `igraph` in a tidy API giving you access to almost all of the dplyr verbs plus a few more, developed for use with relational data.

##

:::{.center-x}
![](img/igraph-meme.jpg)
:::

# Network Visualization

## Visualizing networks is hard(er) {.smaller}

**ordinary data**

- clear data format (rows: observations, columns: variables)
- plot style dependent on variable scale (barchart, scatterplot, boxplot,...) 
- illustrate relations between variables
- given relative positions

:::{.fragment}
**network data**

- different data formats (adjacency matrix, edgelist, adjaceny list, ...)
- **how to choose a proper layout algorithm?**
- more degrees of freedom
- can we draw any conclusions from a network plot?
:::

## which package(s) to choose?

<br>

- {{< CRAN igraph >}}: great for analyses, but plotting can be tricky  
  (check out <https://kateto.net/network-visualization>)
- networks as ggplot2 objects: {{< CRAN ggnet2 >}}, {{< CRAN ggnetwork >}}
- {{< CRAN ggraph >}}:  grammar of graphics for networks
- interactive/3D: {{< CRAN visNetwork >}}, {{< CRAN threejs >}}

## why ggraph?

<br>
<br>

**maintained by Posit**  
stable and reliable (many other packages have been abandoned)  
plays well with other packages

**thoughtful API**  
extension of ggplot2  
grammar of graphics

## First full example (dont panic)

```{r sw_plot}
#| echo: true
#| output-location: slide
#| fig.width: 10
#| fig.height: 6.5
#| fig.align: "center"
#| code-line-numbers: "8-21"
# load and manipulate data
data("starwars")
sw1 <- starwars[[1]]
sw_palette <- c("#1A5878", "#C44237", "#AD8941", "#E99093", "#50594B")
V(sw1)$interactions <- graph.strength(sw1) 

#plot
ggraph(graph = sw1,layout = "stress") + 
  geom_edge_link0(edge_colour = "grey25",
                  aes(edge_width = weight)) +
  geom_node_point(shape = 21, color = "black",stroke = 1,
                  aes(fill = sex,size = interactions)) +
  geom_node_text(color = "black", size = 4, repel = FALSE, 
                 aes(filter = (interactions>=65),label = name))+
  scale_edge_width(range = c(0.1,1.5),guide = "none")+
  scale_size(range = c(3,10),guide = "none")+
  scale_fill_manual(values = sw_palette, na.value = "grey",name = "")+
  coord_fixed()+
  theme_graph() +
  theme(legend.position = "bottom") +
  guides(fill = guide_legend(override.aes = list(size=6)))
```

## 1) layout

:::{.fragment}
:::{.highlight}
`ggraph(graph = sw1,layout = "stress", ...)`
:::
:::

:::{.fragment}
- graph: igraph object sw1 (can also be a tidygraph object)
- layout: used algorithm
- ...: additional parameters depend on algorithm
:::

:::{.fragment}
```{r lay_algos,echo = FALSE,fig.width=16,fig.height=3}
#| echo: false
#| fig.width: 16
#| fig.height: 3

algos <- c("fr","gem","graphopt","kk","mds","circle","stress")
pList <- purrr::map(algos,function(x)
  ggraph(sw1,x)+
    geom_edge_link(edge_width=0.2,edge_colour="grey25")+
    geom_node_point(shape=21,size=2,fill="grey66")+
    theme_graph(background = "white",title_colour = "black",title_size = 13)+
    ggtitle(paste0(x,ifelse(x=="stress"," (graphlayouts)"," (igraph)")))+
    coord_cartesian(clip = "off")
)
wrap_plots(pList,nrow = 1)
```
:::

## 2) edges: geoms

:::{.fragment}
:::{.text07 .highlight}
`geom_edge_link0(edge_colour = "grey25", aes(edge_width = weight))`
:::
:::

:::{.fragment}

```{r geom_edges}
#| echo: true
ls("package:ggraph",pattern = "geom_edge_*")
```

:::

:::{.fragment .text07}
geom_edge_*type*: generate n points, draw path  
geom_edge_*type*0: direct line  
geom_edge_*type*2: can interpolate node parameters 
:::
:::{.fragment .text07}
`geom_edge_link0()` and `geom_edge_parallel0()` suffice
:::

## 2) edges: aesthetics

:::{.fragment}
:::{.text07 .highlight}
`geom_edge_link0(edge_colour = "grey25", aes(edge_width = weight))`
:::
:::

<br>

:::{.fragment}
**mapping aesthetics**  

- **global**: all edges have the same appearance  <br>(e.g. `edge_colour = "grey25"`)  
- **via attributes**: appearance depends on attribute  <br>(e.g. `aes(edge_width = weight)`)
:::

:::{.fragment}
**available aesthetics**  
edge_colo(u)r, edge_width, edge_linetype, edge_alpha  
:::
## 2) edges: aesthetics examples

```{r edge_aes_dotted}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| code-line-numbers: "1-6"
#| fig.align: center
# create a simple graph of three nodes where all nodes are connected
g <- graph.full(3) 
E(g)$weight <- c(1, 2, 0.5)

ggraph(g, "stress") +
  geom_edge_link0(edge_linetype = "dotted")
```

## 2) edges: aesthetics examples

```{r edge_aes_alpha}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "6"
# create a simple graph of three nodes where all nodes are connected
g <- graph.full(3) 
E(g)$weight <- c(1, 2, 0.5)

ggraph(g, "stress") +
  geom_edge_link0(edge_alpha = 0.5)
```

## 2) edges: aesthetics examples

```{r edge_aes_alphaweight}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "6"
# create a simple graph of three nodes where all nodes are connected
g <- graph.full(3) 
E(g)$weight <- c(1, 2, 0.5)

ggraph(g, "stress") +
  geom_edge_link0(aes(edge_alpha = weight, edge_width = weight))
```

## 2) edges: misc

```{r geom_directed}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center

g <- graph.full(3,directed = TRUE)

ggraph(g, "stress") +
  geom_edge_parallel0(edge_width = 0.5,
    arrow = arrow(angle = 15, length = unit(0.15, "inches"),
                  ends = "last", type = "closed"))

```

## 3) nodes: geoms

:::{.fragment}

:::{.text05 .highlight}
`geom_node_point(shape = 21, color = "black",stroke = 1, aes(fill = sex,size = interactions))`
:::

:::

:::{.fragment}
```{r geom_nodes}
#| echo: true
ls("package:ggraph",pattern = "geom_node_*")
```

:::
<br>

:::{.fragment}
- `geom_node_point()`: draw nodes as a simple point
:::

## 3) nodes: aesthetics

:::{.fragment}
:::{.text05 .highlight}
`geom_node_point(shape = 21, color = "black",stroke = 1, aes(fill = sex,size = interactions))`
:::
:::

<br>

:::{.fragment}
**mapping aesthetics**  

- **global**: all nodes have the same appearance <br> (e.g. `shape = 21`)  
- **via attributes**: appearance depends on attribute <br> (e.g. `aes(fill = sex)`)
:::

:::{.fragment}
**available aesthetics**  
alpha, colo(u)r, fill, shape, size, stroke  
*(usage of colour, fill, and stroke depend on shape)*
![](img/points-symbols.png){.absolute right=-50 bottom=20 width="300"}
:::


## 3) nodes: aesthetic examples

```{r geom_node1}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center

g <- graph.full(3)

ggraph(g, "stress") +
  geom_edge_link0() +
  geom_node_point(size = 5, color = "red")
```

## 3) nodes: aesthetic examples

```{r geom_node2}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "5"
g <- graph.full(3)

ggraph(g, "stress") +
  geom_edge_link0() +
  geom_node_point(size = 5, shape = 21, color = "red", fill = "black", stroke = 2)
```

## 3) nodes: aesthetic examples

```{r geom_node3}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "5"
g <- graph.full(3)

ggraph(g, "stress") +
  geom_edge_link0() +
  geom_node_point(size = 5, shape = 22, color = "red", fill = "black", stroke = 2)
```

## 4) labels: geoms

:::{.fragment}

:::{.text06 .highlight}
`geom_node_text(color = "grey25", size = 4, repel = FALSE, aes(filter = (interactions>=65),label = name))`
:::
:::

<br>

:::{.fragment}
- `geom_node_text()`: add text to node
- `geom_node_label()`: add text to node with frame
:::
<br><br>

:::{.fragment}
`geom_node_text` is the preferred choice
:::

## 4) labels: aesthetics

:::{.fragment}

:::{.text06 .highlight}
`geom_node_text(color = "grey25", size = 4, repel = FALSE, aes(filter = (interactions>=65),label = name))`
:::
:::

<br>

:::{.fragment}
**mapping aesthetics**  
- **global**: specify font properties  
- **via attributes**: set label to name attribute of node  
- **filter**: only display for nodes (or edges!) that fulfil a given criterion
:::

<br>

:::{.fragment}
**available aesthetics**  
many! but most important: label, colour, family, size, and repel
:::

## 4) labels: aesthetics examples

```{r geom_node_text}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "7"
g <- graph.full(3)
V(g)$name <- c("David", "Termeh", "Luna")

ggraph(g, "stress") +
  geom_edge_link0() +
  geom_node_point(size = 5, color = "grey66")+
  geom_node_text(aes(label = name), color = "black") + coord_fixed(clip = "off")
```

## 4) labels: aesthetics examples

```{r geom_node_label}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "7"
g <- graph.full(3)
V(g)$name <- c("David", "Termeh", "Luna")

ggraph(g, "stress") +
  geom_edge_link0() +
  geom_node_point(size = 5, color = "grey66")+
  geom_node_label(aes(label = name), color = "black") + coord_fixed(clip = "off")
```


## 5) scales

:::{.fragment}
:::{.text07 .highlight}
`scale_edge_width(range = c(0.1,1.5),guide = "none")`  
`scale_size(range = c(3,10),guide = "none")`  
`scale_fill_manual(values = sw_palette, na.value = "grey",name = "")`
:::
:::
<br>

:::{.fragment}
control aesthetics that are mapped within `aes()`  
although optional, set one `scale_*` per parameter in any `aes()`

**form of scale functions**  
`scale_<aes>_<variable type>()`  

**additional options**  
`guide` (show legend or not), `name` (label in legend), `na.value` (value for NAs)
:::

## 5) scales: variable types

:::{.fragment}
**node size and edge width (and node/edge alpha)**  
`scale_size()` and `scale_edge_width()`  
most relevant parameter is `range = c(min,max)`  
:::

:::{.fragment}
**continuous variable to colour**  
`scale_(edge_)colour_gradient(low = ...,high = ...)`  
:::

:::{.fragment}
**categorical variable to colour**  
`scale_colour_brewer()`  
`scale_colour_manual(values = ...)`
:::

:::{.fragment}
**misc**: `scale_shape()` and `scale_edge_linetype()`
:::
    
## 5) scales: examples

```{r sw-scales1}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "4-5"
ggraph(graph = sw1,layout = "stress") + 
  geom_edge_link0(aes(edge_width = weight)) +
  geom_node_point(size = 5, shape = 21, aes(fill = sex)) +
  scale_edge_width(range = c(0.1,1.5),guide = "none")+
  scale_fill_manual(values = sw_palette, na.value = "grey",name = "")+
  theme(legend.position = "bottom") 
```
    
## 5) scales: examples

```{r sw-scales2}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "1-2"
ggraph(graph = sw1,layout = "stress") + 
  geom_edge_link0(aes(edge_width = weight), show.legend = FALSE) +
  geom_node_point(size = 5, shape = 21, aes(fill = sex)) +
  theme(legend.position = "bottom") 
```
    
## 5) scales: examples

```{r sw-scales3}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "5"
ggraph(graph = sw1,layout = "stress") + 
  geom_edge_link0(aes(edge_width = weight)) +
  geom_node_point(size = 5, shape = 21, aes(fill = sex)) +
  scale_edge_width(range = c(0.1,1.5),guide = "none")+
  scale_fill_brewer(palette = "Set1", na.value = "grey",name = "")+
  theme(legend.position = "bottom") 
```
    
## 5) scales: examples

```{r sw-scales4}
#| echo: true
#| fig.height: 4
#| fig.width: 4
#| fig.align: center
#| code-line-numbers: "3,5"
ggraph(graph = sw1,layout = "stress") + 
  geom_edge_link0(aes(edge_width = weight)) +
  geom_node_point(size = 5, fill = "grey25", aes(shape = sex)) +
  scale_edge_width(range = c(0.1,1.5),guide = "none")+
  scale_shape_manual(values=21:24, na.value = 25,name = "")+
  theme(legend.position = "bottom") 
```

## 6) themes

:::{.highlight .text08}
`theme_graph() + theme(legend.position = "bottom")`
:::

**control the overall look of the plot**  

- `theme()` has a lot of options but we really don't need them (except *legend.position*) 
- `theme_graph()` erases all defaults (e.g. axis, grids, etc.)  

<br>

:::{.text08 .highlight}
`guides(fill = guide_legend(override.aes = list(size=6)))`
:::

change appearance of geoms in legend (highly optional!)

## summary {.smaller}

**layout**  
`ggraph(graph,layout = "stress") + `

**edges**  
`geom_edge_link0(<<global>>,aes(<<via variables>>)) + `

**nodes**  
`geom_node_point(<global>,aes(<via variables>)) + `  
`geom_node_text(<global>,aes(<via variables>)) + `

**scales**  
`scale_<aes>_<variable type>() + ` (one per variable in `aes()`)

**themes**  
`theme_graph()`

## go beyond the standard layout

layout stress is sufficient for most network visualization tasks

```{r more_examples}
#| echo: false
#| fig.width: 20
#| fig.height: 8
#| fig.align: "center"
V(flo_marriage)$size <- degree(flo_marriage)

p1<-ggraph(flo_marriage,"stress") + 
    geom_edge_link0(edge_width = 0.2) +
    geom_node_point(
        shape = 21, fill = "grey25", 
        aes(size = size),show.legend = FALSE) +
    geom_node_text(aes(label = name),size=8,repel=TRUE)+
    theme_graph()+coord_fixed()

V(karate)$grp <- as.character(membership(cluster_louvain(karate)))
p2<-ggraph(karate,"stress") + 
    geom_edge_link0(edge_width = 0.2) +
    geom_node_point(
        shape = 21, size = 8,
        aes(fill = grp),show.legend = FALSE) +
    theme_graph()+coord_fixed()

p1+p2
```


## ego centric layout

Emphasize the position of certain nodes in the network. 

```{r ego_ani_code}
#| echo: true
#| output-location: slide
#| fig.height: 6
#| fig.width: 6
#| fig.align: 'center'
ggraph(sw1,layout = "focus",focus = 19)+
  draw_circle(col = "#00BFFF", use = "focus",max.circle = 3)+
  geom_edge_link0(edge_colour = "grey25",edge_alpha = 0.5)+
  geom_node_point(shape = 21,size = 5,fill = "grey66")+
  geom_node_text(aes(filter = (name=="ANAKIN"),label = name))+
  theme_graph()+
  coord_fixed()
```

<br>

- `focus=...` : id to be put in the center (other nodes are on concentric circles around it)  
- `draw_circle`: draw the concentric circles

## centrality layout

<br>

concentric circle layout according to a centrality index

```{r cent_ani}
#| echo: true
#| output-location: slide
#| fig.height: 6
#| fig.width: 6
#| fig.align: 'center'
strength <- graph.strength(sw1)
ggraph(sw1,layout = "centrality",cent = strength)+
  draw_circle(col = "#00BFFF", use = "cent")+
  geom_edge_link0(edge_colour = "grey25",edge_alpha = 0.5)+
  geom_node_point(shape = 21,size = 5,fill = "grey66")+
  geom_node_text(aes(filter = (strength>=45),label = name),repel = TRUE)+
  theme_graph()+
  coord_fixed()
```

## backbone layout

`layout_as_backbone()` can help emphasize hidden group structures

```{r hairball_artificial}
#| echo: true
g <- sample_islands(9,40,0.4,15)
g <- simplify(g)
V(g)$grp <- as.character(rep(1:9,each = 40))
```

<br>
try the standard first
<br>

```{r hairball_code}
#| echo: true
#| output-location: slide
#| fig.height: 6
#| fig.width: 6
#| fig.align: 'center'
ggraph(g,layout = "stress")+
  geom_edge_link0(edge_colour = "black",edge_width = 0.1, edge_alpha = 0.5)+
  geom_node_point(shape = 21, size = 3, aes(fill = grp))+
  scale_fill_brewer(palette = "Set1")+
  theme_graph()+
  theme(legend.position = "none")
```

## backbone layout

<br>
<br>

try to reveal the hidden group structure with `layout="backbone"`

```{r backbone_code}
#| echo: true
#| output-location: slide
#| fig.height: 6
#| fig.width: 6
#| fig.align: 'center'
#| code-line-numbers: "1,2"
ggraph(g, layout = "backbone")+
  geom_edge_link0(edge_colour = "black",edge_width = 0.1, edge_alpha = 0.5)+
  geom_node_point(shape = 21,size = 3, aes(fill = grp))+
  scale_fill_brewer(palette = "Set1")+
  theme_graph()+
  theme(legend.position = "none")

```

## backbone layout

![](img/facebook.png)
facebook friendships of a university. Node colour corresponds to dormitory of students

## large networks

![](img/squad_network2022.png){.absolute left=85 top=75 width=900 height=900}

## layout summary

**most useful layouts**  
`layout = "stress"`: all purpose layout algorithm  
`layout = "focus"`: ego-centric type layouts  
`layout = "centrality"`: concentric centrality layout  
`layout = "backbone"`: emphasize a group structure (**if it exists**)  
`layout = "sparse_stress"`: large networks  

**not covered here**  
multilevel layouts  
dynamic layouts  
constrained stress layout algorithm

## miscellaneous 

Do not recompute layout continuously
```{r create_layout}
#| eval: false
#| echo: true
#| code-line-numbers: "1,3"
lay <- create_layout(g,"stress")

ggraph(lay) + 
  geom_edge_link0() +
  geom_node_point()
```

But need to recompute the layout if attributes change!

```{r create_layout2}
#| eval: false
#| echo: true
#| code-line-numbers: "1,3"
lay <- layout_with_stress(g)

ggraph(g, "manual", x = xy[,1],y = xy[,2]) + 
  geom_edge_link0() +
  geom_node_point()
```


## edgebundling & flow maps

Using the package {{< CRAN edgebundle >}}

```{r edgebundle}
#| echo: false
#| fig.width: 10
#| fig.height: 4
#| fig.align: 'center'

library(edgebundle)
g <- graph_from_edgelist(
  matrix(c(1,12,2,11,3,10,4,9,5,8,6,7),ncol=2,byrow = T),F)
xy <- cbind(c(rep(0,6),rep(1,6)),c(1:6,1:6))

fbundle <- edge_bundle_force(g,xy,compatibility_threshold = 0.1)
ggplot(fbundle)+
  geom_path(aes(x,y,group=group,col=as.factor(group)),size = 2,show.legend = FALSE)+
  geom_point(data=as.data.frame(xy),aes(V1,V2),size=8)+
  theme_graph(background = "#333333") -> p1

ggraph(g,"manual",x=xy[,1],y=xy[,2]) + 
  geom_edge_link0(edge_width=2) + 
  geom_node_point(shape=21,size=8,fill="black") + 
  theme_graph(background = "#333333") -> p2

p2 + p1
```

##

![](img/flights_nobundle.png)

##

![](img/flights_fdeb.png)

##

![](img/flights_peb.png)

## Summary of the R Ecosystem

- Analyze "standard" networks with {{< CRAN igraph >}}

- Analyze two-mode network projections with {{< CRAN backbone >}}

- Analyze signed networks with {{< signnet >}}

- Missing something? try {{< CRAN netUtils >}}

- Need toy data? use [networkdata](https://github.com/schochastics/networkdata)

- Need a GUI to analyze networks in RStudio? try {{< CRAN snahelper >}}

- "I like my networks tidy" {{< CRAN tidygraph >}}

- "Is there a ggplot2 for networks?" {{< CRAN ggraph >}}

- I cannot do x because it is not implemented in R {{< CRAN netUtils >}}


## Resources beyond this talk

- Tutorial for Network Visualization: <https://www.mr.schochastics.net/material/netVizR/>

- Tutorial for Network Analysis: <https://www.mr.schochastics.net/material/netAnaR/>

- Tutorial for Tidy Network Analysis: <https://www.mr.schochastics.net/material/tidynetAnaR/>