---
title: "Network Analysis in R"
subtitle: ""
author: "David Schoch"
footer: "@schochastics"
institute: "Workshop series for Ukraine"
shortcodes:
  - misc.lua
format: 
  revealjs: 
    menu: true
    progress: false
    theme: "schochastics.scss"
    slide-number: c/t
    show-slide-number: all
    code-line-numbers: false
execute: 
  cache: true
  echo: true
---

```{r}
#| echo: false
#| warning: false
#| message: false
#| label: setup

library(ggraph)
library(igraph)
library(networkdata)
library(netrankr)
```

:::{.center-x}
![](img/qr-code.png){width="400"}  
<https://schochastics.github.io/netAnaR2023>
:::

## My R universe

<img src="img/hex.png" width="400">


## My R universe

<img src="img/hex_net.png" width="605">

# A Short Introduction to Network Analysis


## Why study networks?
conventional research methods are often individual based
and our models tend to model relations between variables

:::{.fragment}
**but nature and culture is structured as networks**
:::

:::{.fragment}
- **society**
- brain (neural networks)
- organizations (who reports to whom)
- economies (who sells to whom)
- ecologies (who eats whom)
:::

:::{.fragment}
**Position within a network is important for predicting outcomes**
:::

## From "ordinary" to network data

<br>

:::{.fragment}
**atomic data**  
individuals or entities
:::

:::{.fragment}
**dyadic data**  
dependent pairs of individuals (e.g. couples)  
but treated as independent entities
:::

:::{.fragment}
**networks**  
interdependent and overlapping dyads    
usual (statistical) independence assumptions do not hold
:::

## 4 pillars of network analysis 

:::{.text15}

 1. Social network analysis is motivated by a structural intuition based on ties linking social actors
 
 2. It is grounded in systematic empirical data
 
 3. It draws heavily on graphic imagery
 
 4. It relies on the use of mathematical and/or computational models

:::


## Levels of Analysis

<br>

:::{.fragment}
**dyad level**  
Fundamental unit of network data collection  
("Does sharing offices lead to friendship?") 
:::

:::{.fragment}
**node level**  
Aggregation of dyad level measurement  
("Do actors with more friends have a stronger immune system?")
:::

:::{.fragment}
**network level**  
Assessing overal structure of a network  
("Do well connected networks diffuse ideas faster?")
:::

:::{.fragment .text08}
more levels are possible (triads, groups, ...)
:::

## Types of relations I

<br>

:::{.fragment}
**Relational states**  

- Similarities: location, participation, attribute  
- Relational roles: kinship, other roles  
- Relational cognition: affective, perceptual
:::

:::{.fragment}
**Relational events**  

- Interactions: sold to, talked to, helped, ...
- Flows: information, belief, money
:::

## Types of relations II

<br>

:::{.fragment}
**undirected**  
symmetric relation
:::

:::{.fragment}
**directed**  
asymmetric relation, but can be bi-directional
:::

:::{.fragment}
**valued**  
strength of relation, frequency of contact, etc.
:::

:::{.fragment}
**signed**  
positive and negative relations
:::

:::{.fragment}
**or a mixture thereof**
:::

## Goals of analysis

:::{.fragment}
**Network variables as independent/explanatory**  

> *Using network theory to explain the consequences of network properties*

social capital, brokerage, adoption of innovation
:::

:::{.fragment}
**Network variables as dependent/outcomes**  

> *Using ______ theory to explain the antecendents of a network*

homophily, balance theory
:::


## A tiny bit of math

network data are represented as **graphs**  
"graph" and "network" are technically different

:::{.frame-box}
A graph $G$ consists of a tuple $(V,E)$ where  
$V=\{1,2,\ldots,n\}$ are the nodes (or vertices)  
$E\subseteq \{(i,j): i,j \in V\}$ are the edges (or ties)
:::

**Most methods rely on concepts from graph theory**

# R Ecosystem for Networks

##

:::{.center-x}
![](img/tidyverse-meme.jpg)
:::


## What is "base R" for networks?

```{r}
#| label: cranet
#| echo: false
g <- readRDS("dependnet.RDS")
ggraph(g, "stress") +
    geom_edge_link0(
        edge_color = "grey66", edge_width = 0.3,
        arrow = arrow(
            angle = 15, length = unit(0.15, "inches"),
            ends = "last", type = "closed"
        )
    ) +
    geom_node_point(shape = 21, aes(fill = dep, size = seed)) +
    scale_fill_brewer(type = "qual", name = "") +
    scale_size_manual(values = c(2, 5), guide = "none") +
    guides(fill = guide_legend(override.aes = list(size = 5))) +
    theme_void() +
    theme(legend.position = "bottom") +
    coord_equal(clip = "off")

```


## Which package to choose?

<br>

use `igraph` if

- you need speed (large networks)
- you need to use other SNA packages

:::{.fragment}
use `sna` if

- you need to do modeling (e.g. ERGMs and RSIENA)
:::

:::{.fragment}
**does not make a difference in most cases, never load them both!**
:::

## Creating simple networks

```{r make_graph}
g1 <- make_graph(c(1,2, 1,3, 2,3, 2,4, 3,5, 4,5), n = 5, dir = FALSE)
g2 <- graph_from_literal(Joey-Chandler:Monica-Ross, Joey-Ross-Rachel)
```
:::: {.columns}
::: {.column width="50%"}
```{r make_graph_lot}
#| echo: false
#| fig.width: 4
#| fig.height: 4
V(g1)$name <- 1:5
ggraph(g1,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  geom_node_text(aes(label=name))+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="50%"}

```{r make_literal_lot}
#| echo: false
#| fig.width: 4
#| fig.height: 4

ggraph(g2,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  geom_node_text(aes(label=name))+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::::

## Special graphs

```{r make_examples}
g3 <- make_full_graph(n = 10)
g4 <- make_ring(n = 10)
g5 <- make_empty_graph(n = 10)
```

:::: {.columns}
::: {.column width="33%"}
```{r full_graph_plot}
#| echo: false
#| fig.width: 3
#| fig.height: 3
ggraph(g3,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="33%"}

```{r ring_plot}
#| echo: false
#| fig.width: 3
#| fig.height: 3

ggraph(g4,"stress") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="33%"}

```{r empty_plot}
#| echo: false
#| fig.width: 3
#| fig.height: 3

ggraph(g5,"nicely") + 
  geom_edge_link0() +
  geom_node_point(shape=21,size=8,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::


::::

```{r igraph_make}
#| eval: false
ls("package:igraph",pattern = "make_*")
```

## Random graphs

```{r make_randoms}
g6 <- sample_gnp(n = 100,p = 0.1)
g7 <- sample_pa(n = 100, power = 1.5, m = 1, directed = FALSE)
```

:::: {.columns}
::: {.column width="50%"}
```{r er_plot}
#| echo: false
#| fig.width: 4
#| fig.height: 4
ggraph(g6,"stress") + 
  geom_edge_link0(edge_width=0.5,edge_color="grey66") +
  geom_node_point(shape=21,size=3,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::

::: {.column width="50%"}

```{r pa_plot}
#| echo: false
#| fig.width: 4
#| fig.height: 4

ggraph(g7,"stress") + 
  geom_edge_link0(edge_width=0.5,edge_color="grey66") +
  geom_node_point(shape=21,size=2,fill="grey66")+
  theme_graph()+
  coord_fixed(clip="off")
```

:::
::::

```{r igraph_sample}
#| eval: false
ls("package:igraph",pattern = "sample_*")
```

## igraph objects 


```{r igraph_obj}
g2
```

<br>

```{r str_igraph}
library(netUtils)
str(g2)
```

## Attributes

:::{.fragment}
**node attributes**
```{r vadd_attr}
V(g2)$name
V(g2)$gender <- c("M","M","F","M","F") 
# g2 <- set_vertex_attr("gender", c("M","M","F","M","F"))
```
:::

:::{.fragment}
**edge attributes**

```{r eadd_attr}
E(g2)
E(g2)$weight <- sample(1:5,size = 6, replace = TRUE)
# g2 <- set_edge_attr("weight", sample(1:5,size = 6, replace = TRUE))
```
:::

## Attributes

```{r igraph_obj1}
g2
```

<br>

```{r str_igraph1}
str(g2)
```

## Network representations: adjacency matrix

```{r adj_mat}
A <- matrix(
  c(0, 1, 1,
    1, 0, 1,
    1, 1, 0),
  nrow = 3, ncol = 3, byrow = TRUE)
rownames(A) <- c("Bob","Ann","Steve")
colnames(A) <- c("Bob","Ann","Steve")
A
```

- $A_{ij}=1$ if there is an edge between $i$ and $j$
- $A$ is symmetric for undirected networks 
- If $A_{ij}>1$ then the values are interpreted as weights 

## Network representation: edgelist

<br>

```{r edge_lst}
el <- matrix(
  c("Bob","Ann",
    "Bob","Steve",
    "Ann","Steve"),
  nrow = 3,ncol = 2, byrow = TRUE)
el
```

more efficient for sparse data (null edges aren't stored)

## Networks from matrices and lists

**adjacency matrix**
```{r from_adj}
graph_from_adjacency_matrix(
  A,
  mode = "undirected",
  weighted = NULL,
  diag = FALSE)
```

**edgelist**
```{r from_edgelist}
graph_from_edgelist(el, directed = FALSE)
```

```{r graph_from}
#| eval: false
ls("package:igraph",pattern = "graph_from_*")
```

## Reading network data

<br>

:::{.fragment}
**Data is already in R (e.g. `networkdata`)**  
No extra work
:::

:::{.fragment}
**Data was processed in another SNA tool**  
```{r read_graph}
#| eval: false
read_graph(file, format = c("edgelist", "pajek", "ncol", "lgl",
  "graphml", "dimacs", "graphdb", "gml", "dl"), ...)
```
Some extra work (with some issues) 
:::

:::{.fragment}
**Data is in a csv/spreadsheet/..**  
`read.table()`, `read.csv()`, {{< CRAN readxl >}}, {{< CRAN readr >}},...
:::

## Preparing network data with attributes {.smaller}

**Organize network data in two separate files**

::::{.columns}
:::{.column width="50%"}
```{r el_df}
#| echo: false
data("greys")
head(igraph::as_data_frame(greys)) |> knitr::kable()
```
:::
:::{.column width="50%"}
```{r node_df}
#| echo: false
head(igraph::as_data_frame(greys,what = "vertices")[,c(1,2,4)]) |> 
  knitr::kable(row.names=FALSE)
```
:::
:::

<br>

```{r df1}
#| eval: false
graph_from_data_frame(el, directed = c(TRUE, FALSE), vertices)
```

# Descriptive Statistics and some graph theory

## Toy example
```{r load_greys}
data("greys")
```


```{r plot_greys}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
ggraph(greys,"stress",bbox=10) + 
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,aes(fill=sex),size=5,show.legend = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE)+
  scale_fill_manual(values=c("grey66","#E8813A","#4D189D"))+
  theme_void()
```

## Density

<br>

The **density** of a network is defined as the fraction of the potential edges in a network that are actually present.
```{r density}
c(graph.density(make_empty_graph(10)), 
  graph.density(greys), 
  graph.density(make_full_graph(10)))
```

## Shortest Paths

A **shortest path** is a path that connects two nodes in a network with a minimal number of edges. The length of a shortest path is called the distance between two nodes.

```{r shortest_path}
shortest_paths(greys,from = "Alex Karev",to = "Owen Hunt",output = "vpath")
```

## Shortest Paths
```{r greys_shortest_path}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
E(greys)$epath <- FALSE
E(greys)$epath[as.integer(shortest_paths(greys,from = "Alex Karev",to = "Owen Hunt",output = "epath")$epath[[1]])] <- TRUE

ggraph(greys,"stress",bbox=10) + 
  geom_edge_link0(aes(color=epath,width=epath),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=sex),size=5,show.legend = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE)+
  scale_fill_manual(values=c("grey66","#E8813A","#4D189D"))+
  scale_edge_color_manual(values=c("grey66","firebrick3"))+
  scale_edge_width_manual(values=c(0.5,1.5))+
  theme_void()

```

## Distances

```{r distances}
distances(greys)[1:5,1:5]
```

The Grey's Anatomy network is **disconnected** ($4$ **connected components**)

## Diameter

The length of the longest shortest path is called the **diameter** of the network.

```{r diameter}
diameter(greys)
```

```{r greys_diameter}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
E(greys)$epath <- FALSE
E(greys)$epath[as.integer(shortest_paths(greys,from = "Finn Dandridge",to = "Colin Marlow",output = "epath")$epath[[1]])] <- TRUE

ggraph(greys,"stress",bbox=10) + 
  geom_edge_link0(aes(color=epath,width=epath),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=sex),size=5,show.legend = FALSE)+
  geom_node_text(aes(label=name),repel = TRUE)+
  scale_fill_manual(values=c("grey66","#E8813A","#4D189D"))+
  scale_edge_color_manual(values=c("grey66","firebrick3"))+
  scale_edge_width_manual(values=c(0.5,1.5))+
  theme_void()

```

## Transitivity

**Transitivity** is a measure of the degree to which nodes in a graph tend to cluster together. This is also called the **clustering coefficient**. 

**local**  
gives an indication of the embeddedness of single nodes

```{r ccoef_example}
#| echo: false
#| fig.width: 15
#| fig.height: 5
#| fig.align: center
library(patchwork)
g1 <- make_full_graph(4)
V(g1)$focal <- FALSE
V(g1)$focal[1] <- TRUE
E(g1)$from1 <- FALSE
E(g1)$from1[incident_edges(g1,1)[[1]]] <- TRUE
xy <- graphlayouts::layout_with_stress(g1)
xy <- graphlayouts::layout_rotate(xy,20)
p1 <- ggraph(g1, "manual",x = xy[,1],y = xy[,2]) + 
  geom_edge_link0(aes(edge_width=from1,edge_color=from1),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=focal),show.legend = FALSE,size=15,stroke=1.5)+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_edge_width_manual(values=c(2,0.5))+
  scale_edge_color_manual(values=c("grey25","grey66")) + 
  theme_graph()+
  coord_cartesian(clip = "off")

g2 <- delete.edges(g1,c(4,6))
p2 <- ggraph(g2, "manual",x = xy[,1],y = xy[,2]) + 
  geom_edge_link0(aes(edge_width=from1,edge_color=from1),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=focal),show.legend = FALSE,size=15,stroke=1.5)+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_edge_width_manual(values=c(2,0.5))+
  scale_edge_color_manual(values=c("grey25","grey66")) + 
  theme_graph()+
  coord_cartesian(clip = "off")

g3 <- delete.edges(g1,c(4,5,6))
p3 <- ggraph(g3, "manual",x = xy[,1],y = xy[,2]) + 
  geom_edge_link0(aes(edge_width=from1,edge_color=from1),show.legend = FALSE)+
  geom_node_point(shape=21,aes(fill=focal),show.legend = FALSE,size=15,stroke=1.5)+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_edge_width_manual(values=c(0.5,0.5))+
  scale_edge_color_manual(values=c("grey66","grey66")) + 
  theme_graph()+
  coord_cartesian(clip = "off")

p1 + p2 + p3

```

:::: {.columns}

::: {.column width="65%"}
**global**  
indication of the clustering in the network
:::

::: {.column width="35%"}
$$
\frac{3 \times \text{number of triangles} }{\text{total number of triplets}}
$$

:::

::::

## Transitivity
```{r transitivity}
data("coleman")
g <- as.undirected(coleman[[1]])
transitivity(g, type = "global")
```

```{r transitivity2}
transitivity(g, type = "local", isolates = "zero")
```

In empirical networks, we often observe a tendency towards high transitivity ("the friend of a friend is a friend")  

What do you think is the (local/global) transitivity of `greys`?

## Transitivity
<br>

The value itself is not always enough to judge the level of transitivity of a network. We should also check if it deviates significantly from what would be expected by randomness

```{r transitivity3}
deg <- degree(g)
# keep density fixed
mean(replicate(500,transitivity(rewire(g,each_edge(1)),type = "global")))

# keep degree sequence fixed
mean(replicate(500,transitivity(sample_degseq(deg),type = "global")))
```
## Degree distribution

<br>

The **degree** of a node in a network is the number of connections it has to other nodes.

The **degree distribution** is the probability distribution of the degrees over the whole network.

Empirical degree distributions are generally right skewed.  
(Many nodes have a few conncetions and few have many)
"preferential attachment", "matthew effect", "the rich get richer"  

## Degree distribution

<br>

```{r deg_dist_graphs}
er <- sample_gnp(n = 5000, p = 0.01)
pa <- sample_pa(n = 5000, power = 1.5, m = 2, directed = FALSE)
```

<br>

:::: {.columns}

::: {.column width="50%"}

```{r dd_er}
plot(degree_distribution(er))
```

:::

::: {.column width="50%"}

```{r dd_pa}
plot(degree_distribution(pa),log = "xy")
```

:::

::::

## Centrality

A **measure of centrality** is an index that assigns a numeric values to
the nodes of the network. The higher the value, the more central the node. 

"Being central" is a very ambiguous term hence there exists a large variety of indices that assess centrality with very different structural properties.

```{r star_net}
#| echo: false
#| fig.align: center
#| fig.width: 4
#| fig.height: 4
g<-graph.star(8,"undirected")
V(g)$center <- c(T,rep(F,7))
ggraph(g,"stress") + 
  geom_edge_link0(edge_width = 2,edge_color="white")+
  geom_node_point(shape=21,aes(fill=center,size=center),color="white") + 
  theme_graph(background = "#333333")+
  scale_fill_manual(values=c("grey66","#ffd700"))+
  scale_size_manual(values=c(7,14))+
  theme(legend.position = "none")
```


##

```{r periodic}
#| echo: false
knitr::include_graphics("img/periodic_table.png")
```

## Standard indices {.text09}

**Degree**  
Number of direct neighbors ("popularity")  

**Closeness**  
Reciprocal of the sum of the length of the shortest paths

**Betweenness**  
Number of shortest paths that pass through a node ("brokerage")

**Eigenvector**  
Being central means being connected to other central nodes

**PageRank**  
Similar to eigenvector, just for directed networks 

## Toy example I

```{r load_dbces}
data("dbces11")
```

```{r dbces11_basic_plot}
#| echo: false
xy <- graphlayouts::layout_with_stress(dbces11)
ggraph(dbces11,"manual",x=xy[,1],y=xy[,2])+
  geom_edge_link0()+
  geom_node_point(shape=21,size=10,fill="grey66")+
  geom_node_text(aes(label=name))+
  theme_void()+
  coord_equal(clip = "off")
```

## Toy example I

```{r load_dbces1}
#| eval: false
data("dbces11")
```

```{r dbces11_plot}
#| echo: false
V(dbces11)$cent <- NA
V(dbces11)$cent[which.max(degree(dbces11))] <- "DC"
V(dbces11)$cent[which.max(betweenness(dbces11))] <- "BC"
V(dbces11)$cent[which.max(closeness(dbces11))] <- "CC"
V(dbces11)$cent[which.max(eigen_centrality(dbces11)$vector)] <- "EC"
V(dbces11)$cent[which.max(subgraph_centrality(dbces11))] <- "SC"

ggraph(dbces11,"manual",x=xy[,1],y=xy[,2])+
  geom_edge_link0()+
  geom_node_point(shape=21,size=10,aes(fill=cent),show.legend = FALSE)+
  geom_node_text(aes(filter=!is.na(cent),label=cent))+
  theme_void()+
  coord_equal(clip = "off")
```


## Implemented indices {.smaller}

`igraph` contains the following 10 indices:

- [degree (`degree()`)]{.highlight}
- [weighted degree (`strength()`)]{.highlight}
- [betweenness (`betweenness()`)]{.highlight}
- [closeness (`closeness()`)]{.highlight}
- [eigenvector (`eigen_centrality()`)]{.highlight}
- alpha centrality (`alpha_centrality()`)
- power centrality (`power_centrality()`)
- [PageRank (`page_rank()`)]{.highlight}
- eccentricity (`eccentricity()`)
- hubs and authorities (`authority_score()` and `hub_score()`)
- subgraph centrality (`subgraph_centrality()`)

## Indices in the sna package

The `sna` package implements roughly the same indices as but adds:

- flow betweenness (`flowbet()`)
- load centrality (`loadcent()`)
- Gil-Schmidt Power Index (`gilschmidt()`)
- information centrality (`infocent()`)
- stress centrality (`stresscent()`)

## Dedicated packages

{{< CRAN centiserve >}}, {{< CRAN CINNA >}}  
```{r centiserve}
library(centiserve)
as.character(lsf.str("package:centiserve"))
```

[centiserver](http://www.centiserver.org/) lists more than 400 indices

CINNA:  
Computing and comparing top informative centrality measures 

## Alternatives?

{{< CRAN netrankr >}}:  
Tools which allow an indexfree assessment of centrality, including:  

- partial centrality
- expected centrality
- probabilistic centrality

:::{.callout-tip}
## Help

Tutorials and material for using netrankr can be found at [netrankr.schochastics.net](http://netrankr.schochastics.net/)

:::

# 

## Cohesive groups

Cohesive subgroups are subsets of actors among whom there are relatively strong, direct, intense, frequent, or positive ties. 

Methods that formalize the intuitive and theoretical notion of social group using social network properties

:::{.center-x}
![](img/cohesive.png){width="950"}
:::

## Cliques

A *clique* in a network is a set of nodes that form a complete subnetwork within a network (called a complete **subgraph**). 

A **maximal clique** is a clique that cannot be extended to a bigger clique by addding more nodes to it. 

```{r load_clique_graph}
data("clique_graph")
```

```{r clique_graph}
#| echo: false
#| fig.align: center
ggraph(clique_graph,"stress") +
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=8,fill="grey25")+
  theme_graph()
```

## Cliques

Maximal cliques can be calculated with `max_cliques()` 
```{r calc_max_cliques}
# only return cliques with three or more nodes
cl <- max_cliques(clique_graph,min = 3)
cl
```

## Cliques


```{r clique_graph_2}
#| echo: false
#| fig.align: center

xy <- graphlayouts::layout_with_stress(clique_graph)

cl_df <- as.data.frame(do.call("rbind",
  lapply(seq_along(cl),function(x){
    cbind(xy[cl[[x]],],x)
  })
))

ggraph(clique_graph,"stress") +
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=8,fill="grey25")+
  ggforce::geom_mark_hull(data = cl_df,aes(V1,V2,fill=as.factor(x),group=x),show.legend = FALSE)+
  scale_fill_manual(values=c("#E69F00", "#000000", "#56B4E9", "#009E73", "#F0E442", "#0072B2", 
                             "#D55E00", "#CC79A7", "#666666"))+
  theme_void()
```

## k-core decomposition

A **k-core** is a subgraph in which every node has at least k neighbors within the subgraph. A k-core is thus a relaxed version of a clique.  

```{r kcore}
kcore <- coreness(clique_graph)
kcore
```

```{r kcore_plot}
#| echo: false
#| fig.align: center
cl_df <- as.data.frame(do.call("rbind",
  lapply(sort(unique(kcore))[c(2,3,4)],function(x){
    cbind(xy[kcore>=x,],x)
    })
))

ggraph(clique_graph,"stress") +
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape = 21,size = 8,fill="grey25")+
  ggforce::geom_mark_hull(data = cl_df,aes(V1,V2,fill=as.factor(x),group=x),show.legend = FALSE)+
  scale_fill_manual(values=c("red","blue","green"))+
  theme_void()

```

## Clustering/Community detection

**Minimum-cut method**  
cut graph into partitions which minimizes some metric

**Hierarchical clustering**  
Agglomerative/Divisive methods to build a hierarchy of clusters  
based on node similarity

**Modularity Maximization**  
Modularity is defined as the fraction of edges that fall within given groups minus the expected fraction if edges were random

**Statistical inference**  
[stochastic blockmodeling](https://graph-tool.skewed.de/) based on generative models

## Min Cut clustering

```{r mincut}
g <- sample_islands(2,10,0.9,5)
g <- simplify(g)
```
:::: {.columns}

::: {.column width="50%"}
```{r mincut_plot}
#| echo: false
#| fig.width: 4
#| fig.height: 4
#| fig.align: center
V(g)$name <- 1:vcount(g)
ggraph(g,"stress") + 
   geom_edge_link0(edge_width = 0.4) +
   geom_node_point(shape=21, size = 5,fill= "grey66") +
   geom_node_text(aes(label = name),size=3) +
   theme_graph()
```
:::

::: {.column width="50%"}
```{r mincut_calc}
min_cut(g,value.only = FALSE)
```
:::
::::

Really only works in very obvious cases.

## Hierarchical clustering

```{r hierarch_clust}
#| fig.width: 8
#| fig.height: 6
#| fig.align: center
D <- distances(g)
hclust_avg <- hclust(as.dist(D), method = "average")
cut_avg <- cutree(hclust_avg, k = 2)

plot(hclust_avg)
rect.hclust(hclust_avg , k = 2, border = 2:6)
abline(h = 2, col = 'red')
```


## Clustering with igraph

<br>

- There is no agreed upon best method
- Modularity maximization is still widely considered "state-of-the-art"
- Generative models are, however, a strong contender  
  (not implemented in R yet)

```{r cluster_alg}
ls("package:igraph",pattern = "cluster_")
```

## Clustering workflow

```{r karate}
data("karate")
```

```{r karate_plot}
#| echo: false
#| fig.align: center
ggraph(karate,"stress")+
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=5,fill="grey66")+
  theme_void()+
  coord_equal()
```

## Clustering workflow

```{r cluster_ex}
# compute clustering
clu <- cluster_louvain(karate)

# cluster membership vector
mem <- membership(clu)
mem

# clusters as list
com <- communities(clu)
com
```

## Clustering workflow

<br>

```{r karate_cluster}
imc <- cluster_infomap(karate)
lec <- cluster_leading_eigen(karate)
loc <- cluster_louvain(karate)
sgc <- cluster_spinglass(karate)
wtc <- cluster_walktrap(karate)

scores <- c(infomap = modularity(karate,membership(imc)),
            eigen = modularity(karate,membership(lec)),
            louvain = modularity(karate,membership(loc)),
            spinglass = modularity(karate,membership(sgc)),
            walk = modularity(karate,membership(wtc)))

scores
```

## Cluster workflow

```{r karate_plot_clu}
#| echo: false
#| fig.align: center
V(karate)$clu <- membership(sgc)
ggraph(karate,"stress")+
  geom_edge_link0(edge_color="grey66")+
  geom_node_point(shape=21,size=5,aes(fill=as.factor(clu)),show.legend=FALSE)+
  theme_void()+
  coord_equal()
```
# Beyond "standard" networks

## Two-mode networks

A **two-mode network** is a network that consists of two disjoint sets of nodes (like people and events)

Common examples include:   

- Affiliation networks (Membership in institutions)
- Voting/Sponsorship networks (politicians and bills)
- Citation network (authors and papers)
- Co-Authorship networks (authors and papers)

## Toy example

```{r southern_dat_load}
data("southern_women")
```

```{r southern_women}
#| echo: false
#| fig.align: center
ggraph(southern_women,"stress")+
  geom_edge_link(edge_color="grey66")+
  geom_node_point(aes(fill=type,shape=type),size=8,show.legend = FALSE)+
  geom_node_text(aes(label=name))+
  scale_shape_manual(values=c(21,22))+
  theme_void()

```

## Analyzing two-mode networks 

<br>

The adjacency matrix is called **incidence matrix**

```{r incidence_southern}
A <- as_incidence_matrix(southern_women)
A[1:8, ]
```

{{< CRAN tnet >}} and {{< CRAN bipartite >}}  offer some methods to analyse two mode networks **directly**, by adapting tools for standard networks.

## Projecting two-mode networks

![](img/small_project.png)

```{r proj_women}
B <- A%*%t(A)
B[1:5,1:5]
```

## Projecting two-mode networks
```{r plot_weighted_proj}
#| echo: false
#| fig.align: center

proj <- graph_from_adjacency_matrix(B,weighted = TRUE,diag = FALSE,mode = "undirected")

ggraph(proj,"stress")+
  geom_edge_link(aes(edge_width=weight),edge_color="grey66",show.legend = FALSE)+
  geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
  geom_node_text(aes(label=name))+
  scale_edge_width(range = c(1,4))+
  theme_void()+
  coord_cartesian(clip = "off")

```

## Filtering projections

![](img/proj_flow.png)

**naïve**  
delete all edge with a weight less than x

**advanced**  
statistical tools using null models: {{< CRAN backbone >}}  
[Introduction to the package](https://arxiv.org/abs/1912.12779)

## "Backbone" null models

Compare an edge's observed weight in the projection to the distribution of weights expected in a projection obtained from a random bipartite network where both the row vertex degrees and column vertex degrees are ...

**Fixed degree sequence model**  
... *exactly* fixed at their original values

**Stochastic degree sequence model**  
... *approximately* fixed at their original values

## "Backbone" example

```{r southern_backbone}
library(backbone)
sw_bb <- sdsm(southern_women,alpha = 0.4)
```

```{r sw_bb_plot}
#| echo: false
#| fig.width: 12
#| fig.height: 8
#| fig.align: center
ggraph(sw_bb,"stress")+
  geom_edge_link(edge_width=0.6,edge_color="grey66",show.legend = FALSE)+
  geom_node_point(shape=21,fill="grey66",size=8,show.legend = FALSE)+
  geom_node_text(aes(label=name))+
  scale_edge_width(range = c(1,4))+
  theme_void()+
  coord_cartesian(clip = "off")
```


## Application of projections

**Co-voting behavior of US senators**

![](img/senate.jpg)

[Link to paper](https://www.nature.com/articles/s41598-020-74175-w)


## Signed networks

<br>

Signed networks include two types of relations:  
positive ("friends") and negative ("foes")

typical research questions involve (implemented in {{< CRAN signnet >}}):

- structural balance
- blockmodeling
- (centrality)

## Structural balance theory
<br>

**developed by Heider in 1940s**:  

- mental discomfort when actors hold contradictory beliefs
- there is a preference for ’balance’ (consistency) states
- states of imbalance and mental discomfort create ’tension’
- imbalanced states are unstable
- imbalanced states move towards balance

**formalised with graph theory by Cartwright Harary (1950s)**

## Structural balance theory

:::{.center-x}
![](img/balance_triples.png){width="900"}
:::

**Beyond triangles**  
A network is balanced if it can be partitioned into two groups such that all intra group edges are positive and all inter group edges are negiative

**Extended form of balance** (Davis 1960s)  
A network is balanced if it can be partitioned into k groups ...


## Toy example

<br>

```{r sign example}
library(signnet)
data("tribes")
```

:::{.columns}
:::{.column width="49%"}
```{r tribes_now}
ggsigned(tribes)
```
:::

:::{.column width="49%"}
```{r tribes_w}
ggsigned(tribes,weights = T)
```
:::
:::

## Measuring structural balance

- **triangles**: Fraction of balanced triangles. 
- **walks**: fraction of signed to unsigned walks
- **frustration**: optimal partition such that the sum of intra group negative and inter group positive edges is minimized

```{r balance_scores}
balance_score(tribes,method = "triangles")
balance_score(tribes,method = "walk")
balance_score(tribes,method = "frustration")
```


## Blockmodeling

In signed blockmodeling, the goal is to determine $k$ blocks of nodes such that all intra-block edges are positive and inter-block edges are negative

```{r signed_bm}
set.seed(141)
bl <- signed_blockmodel(tribes,3)
bl
```

```{r signed_bm_plot}
#| fig.align: center
#| fig.width: 6
#| fig.height: 6
#| output-location: slide
ggblock(tribes,blocks = bl$membership,show_blocks = TRUE,show_labels = TRUE)
```

## Generalized blockmodeling

The diagonal block structure is not always the most optimal representaion of the data
```{r weird_signed}
#| echo: false
#| fig.height: 5
#| fig.width: 10
#| fig.align: center
library(patchwork)
g1 <- g2 <- g3 <- graph.full(5)

V(g1)$name <- as.character(1:5)
V(g2)$name <- as.character(6:10)
V(g3)$name <- as.character(11:15)

g <- Reduce("%u%",list(g1,g2,g3))
E(g)$sign <- 1
E(g)$sign[1:10] <- -1
g <- add.edges(g,c(rbind(1:5,6:10)),attr = list(sign=-1))
g <- add.edges(g,c(rbind(1:5,11:15)),attr = list(sign=-1))
g <- add.edges(g,c(rbind(11:15,6:10)),attr = list(sign=1))

p1<-ggsigned(g,weights = FALSE)
p2<-ggblock(g,rep(1:3,each=5),show_blocks = TRUE)
p1+p2
```

## Generalized blockmodeling

The function `signed_blockmodel_general()` allows to specify arbitrary block structures.
```{r gen_block_mat}
set.seed(424) #for reproducibility
blockmat <- matrix(c(1,-1,-1,-1,1,1,-1,1,-1),3,3,byrow = TRUE)
blockmat

general <- signed_blockmodel_general(g,blockmat,alpha = 0.5)
traditional <- signed_blockmodel(g,k = 3,alpha = 0.5,annealing = TRUE)

c(general$criterion,traditional$criterion)
```

## Generalized blockmodeling
:::{.center-x}
![](img/blockmodel_general.png){width="750"}
:::

## Other functions

Most functions us the igraph name + `_signed`:

- `as_adj_signed()`
- `as_incidence_signed()`
- `laplacian_matrix_signed()`
- `triad_census_signed()`
- `degree_signed()`
- `eigen_centrality_signed()`
- `sample_islands_signed()`

## All signed triads

:::{.center-x}
![](img/signed_triads.png){width="600"}
:::